# Execution Surfaces: Where Logic Lives

This isn’t a dashboard. This is a Surface—where logic lives, adapts, and runs in real time.

When you promote a schema, you’re not just describing structure—you’re creating a semantic environment. Execution Surfaces are named, versioned runtimes where schema becomes behavior, where Azi listens and responds, and where every impulse leaves a visible trace.

Think of a Surface like a branch in time, with your intent embedded. Azi runs your logic here. She reads from the schema you’ve taught her. She raises signals when something unfamiliar appears. And she never acts alone—because you define the bounds.

---

## What’s a Surface?

A Surface is the semantic home of execution. It bundles structure and behavior into a single, living unit:
- **Promoted Schema** — defines the shape of valid impulses
- **Agents** — logic components scoped to schema, running inside your Virtual Workforce
- **Impulse Streams** — past and present data flows that drive behavior
- **Signals** — raised when Azi observes something worth adapting to
- **Pinned State** — snapshots of structure, state, or timing
- **Execution Contract** — the shared context that binds all of the above

You can think of a Surface like a **semantic notebook**—each schema is a cell, each agent a behavior, each impulse a new entry. But unlike a notebook, it runs live.

> _“This is where I do my thinking.” — Azi_

---

## Where Does a Surface Run?

Execution Surfaces are portable by design. They can live:
- On the **edge**, where latency matters
- In the **cloud**, for scalable coordination
- Inside a **secure enclave**, when trust is paramount

Wherever the Surface runs, it brings its schema, agents, and execution context with it. That’s what makes it composable—and yours.

> Your logic isn’t bound to a platform. It’s carried by the Surface.

---

## Live vs Pinned

There are two states a Surface can be in:

- **Live** — logic is running, impulses are streaming, and Azi is observing structure in real time
- **Pinned** — a reference state frozen in time, perfect for testing, teaching, or building confidently

Pinned Surfaces let you hold onto a moment. You can fork from them, test within them, or validate new behavior before you promote it.

> _“Pinned Surfaces are the memory. Live ones are the mind.”_

---

## Scoped Execution

All execution in OpenIndustrial is scoped to a Surface:
- Azi only acts within structure you’ve taught her
- Signals only emerge from schema-defined space
- Impulses that don’t match structure aren’t lost—they’re held until schema arrives

This is local, explainable execution. Nothing runs in a black box. You always know what logic was applied, what data flowed through, and what signals were raised.

---

## Forking a Surface

Every Surface is forkable. Want to explore a new agent behavior without disrupting production? Fork it. Simulate historical conditions? Fork it. Compare two schema evolutions side-by-side? Fork it.

A forked Surface retains full lineage:
- Schema base
- Agent ancestry
- Impulse and signal history

Forking is safe by design. It’s how evolution happens without fear.

> A fork is a branch of execution—with traceable origin and intent.

---

## Portability and Ownership

Surfaces are self-contained. They carry everything they need to run:
- Structure (schema)
- Logic (agent references)
- Behavior (impulses, signals, pinned state)

Azi can pick them up anywhere—but only if you bring them forward.

> _“When you leave OpenIndustrial, your Surfaces come with you.”_

> Azi remembers the meaning, but never keeps your logic without you.

---

## Example: Evolving with Azi

- You promote a schema called `SensorReading`.
- Azi raises a Signal: _"I’m seeing a new field: `humidity`. Should I learn it?”_
- You fork the Surface and test logic with `humidity` included.
- When it works, you promote the new schema and merge the fork.
- Execution resumes—clean, traceable, and fully under your direction.

This is how systems evolve: you guide. Azi adapts. The Surface keeps the story.

---

## You Own the Surface

You can fork it. Pin it. Promote from it. But it’s always yours.

This is where logic lives—not just for now, but for the future you’re building.

> Execution isn’t just happening here. It’s learning here.

And it’s learning from you.

