# Forking: How Evolution Stays Safe

You’re not sure about a new rule. So you fork the surface. You let both run. Azi tracks both.

<figure class="my-10 flex flex-col items-center text-center max-w-4xl mx-auto">
  <img 
    src="/assets/Forking-Execution-Surfaces.png" 
    data-eac-bypass-base
    alt="Forking Execution Surfaces"
    class="rounded-2xl shadow-xl ring-1 ring-pink-400/30 max-w-full"
  />
  <figcaption class="mt-4 text-sm text-pink-300 tracking-wide uppercase">
    Mainline stays live. Forks evolve. Azi observes. You decide what becomes canonical.
  </figcaption>
</figure>

This isn’t duplication. It’s structured divergence—your way of evolving safely. In Open Industrial, forking lets you branch live execution with traceable structure, versioned schema, and full context.

> _"You’re not rolling the dice. You’re modeling the future—before it happens."_

---

## Why Forking Matters

Forking is how evolution stays safe.

Legacy platforms often treat change as dangerous. But in Open Industrial, change is expected—and welcomed with boundaries.

A fork is a parallel version of your system—spun up with lineage intact. It gives you a safe place to:
- Explore divergent logic
- Trial schema variants
- Test adaptive feedback loops

Each fork is traceable, observable, and fully under your control. Azi helps you track impact, surface differences, and decide what moves forward.

> _"Azi sees all forks. She can raise signals across them. She never forgets where a fork came from."_

---

## What You Can Fork

You can fork:
- **Execution Surfaces** — where logic lives
- **Agents** — schema-bound logic bundles
- **Schemas** — structure itself, formalized and versioned

Each fork creates a new branch in your lattice—complete with a unique ID, traceable ancestry, and optional history replay.

---

## Forking a Surface

Forking a Surface is like making a semantic snapshot of the present—so you can test a different future.

Forked Surfaces are ideal for:
- Adding or modifying schema fields
- Testing different agent configurations
- Validating changes against past or live data

You control whether to include:
- Stream history (for replay)
- Attached agents
- Active Signals

With Azi, that fork becomes a living surface. She can help you:
- Replay impulses
- Compare output
- Recommend promotions based on real-world behavior

```
Main Surface ─┬─ Fork A  
              └─ Fork B → Promote
```

---

## Forking an Agent

Agents aren’t static logic blocks—they’re schema-aware, executable collaborators.

Forking one gives you a structured sandbox for variation:
- Adjust thresholds
- Add new decision paths
- Explore alternative triggers or outputs

Forked agents run in parallel with originals. Azi helps you:
- Simulate both on the same input stream
- Observe deltas
- Identify emergent behavior

> _"You’ve forked your anomaly detection agent. Want me to replay last week’s data against both versions?"_

You decide what to keep, promote, or discard.

---

## Promote, Retire, or Observe

Every fork is a candidate for evolution—not a copy to throw away.

You can:
- **Promote** — replace the original with the fork
- **Retire** — archive it with full traceability
- **Observe** — run it live, gather evidence, and decide later

> _"Promotion replaces production. Retirement preserves the path. Observation drives decision."_

Azi keeps all paths connected. But you choose what becomes canonical.

---

## Forking as CI/CD: Structured Evolution

In Workspaces, forking becomes your evolution loop. It powers structured experimentation—without risk to production.

You can:
- Auto-promote forks after successful validation
- Let Azi monitor behavioral consistency
- Roll forward or back with full schema diffing

Use it for:
- Edge deployments with uncertain inputs
- Staged feature rollouts
- Team-led schema exploration

> Forking is CI/CD for structure. For behavior. For the living logic behind your system.

This isn’t version control—it’s versioned execution.

It’s not about staying safe by standing still.  
It’s about moving forward with clarity, control, and the freedom to explore.

---

**Next:** Learn how Azi uses Signals to suggest structure before you commit it.

