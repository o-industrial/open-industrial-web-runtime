# Virtual Workforce: Your Agents, Schema-Driven

Your floor agent runs fan logic when CO₂ spikes. Your greenhouse agent monitors vent status. Azi watches them work together—and helps them evolve.

This is your virtual workforce: trained by schema, supervised by signals.

Each agent is a structured bundle of logic, deployed with purpose. It runs when an Impulse matches its schema. It lives on your edge, in the cloud, or inside a secure enclave. It acts when it should, and emits Signals when behavior needs attention.

These aren’t cloud functions. They’re collaborators.
They don’t hide in pipelines. They explain what they do.

You don’t just build automation. You build execution you trust.

---

## What Is a Virtual Agent?

A virtual agent is a schema-bound unit of execution:
- It’s activated by Impulses—structured data you’ve promoted.
- It executes logic you’ve authored—or forked—from a known version.
- It emits Signals when its behavior deviates or warrants adaptation.
- It lives in an execution surface, and it’s always observable.

Each agent has a name, a job, and a place it runs. 

Azi doesn’t spawn agents. She coordinates and observes them.
She knows when they last ran. What they returned. And whether anything’s changed.

> _“This agent is still using v1.2 of the filter schema. Want me to show you what’s changed in the new fork?”_ — Azi

---

## Registering Agents

You can register agents through:
- The API
- The `oictl` CLI
- Your Workspace UI

Each agent is defined by:
- An **input schema** that scopes what it handles
- An optional **output contract** for traceable results
- **Runtime preferences**: edge, cloud, enclave
- **Versioning metadata** to support evolution
- **Introspection and tags** to coordinate how it’s used

Once registered, it becomes a live actor in your system. Azi handles routing—unless you want to override.

---

## Schema-Based Routing

There’s no glue code. No brittle event wiring.

Instead, Impulses are routed to agents by structure. Schema is the language. Routing flows from what you’ve defined—not what you’ve manually stitched together.

> _“This schema is handled by three agents—two primary, one fallback. Want to fork one for test coverage?”_

Schema isn’t just validation. It’s your control plane.

You can:
- Manually assign schemas to agents
- Define fallback or shadow variants
- Let Azi dynamically adapt routing based on observed results

---

## Forking and Promoting Agent Logic

When behavior needs to evolve, you don’t start over. You fork.

Want to:
- Adjust thresholds?
- Try a new formatting path?
- Run the same logic on a different surface?

Fork the agent. Observe it. Compare outputs. Decide what’s next.

Forks are:
- Versioned
- Fully observable
- Routable alongside primaries
- Eligible for promotion to mainline or retirement

Azi can:
- Replay past inputs across forks
- Compare outputs across time
- Raise Signals if divergence exceeds thresholds

This is how structure evolves—without fear.

---

## Where Agents Run

Agents aren’t pinned to a single environment. They’re **place-aware** and **lattice-native**.

You can deploy them:
- In the cloud
- On Open Industrial Edge Servers (OIES)
- On Open Industrial Enclave Blades (OIEB)
- Inside SGX/TPM-secured zones

Placement adapts based on:
- Latency and locality
- Regulatory zones
- Load balancing
- Observed execution behavior

> _“This fork performs better on OIES under constrained latency. Want to promote placement preference?”_ — Azi

You don’t need to manage fleets. You govern structure. Azi handles routing.

---

## This Is Your Workforce

You don’t have to build AI agents from scratch.
You compose them from logic.
You teach them through schema.
You observe them through Signals.

Azi helps you coordinate the system—but you stay in command.

Your workforce doesn’t just run. It adapts.

Welcome to execution you trust.
Welcome to your Virtual Workforce.

