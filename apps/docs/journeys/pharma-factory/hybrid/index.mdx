# Hybrid OT Integration – Govern Without Replacing

> “The QA lead escalated a batch failure after a CIP cycle. Historian showed green — but no agent ever confirmed the drain. $1.9M recall. That signal vanished. Here, it’s remembered.”

You’ve been here before. Black-box logic said everything checked out — but your audit logs, QA flags, or historian trends told a different story. In a world of fragmented industrial systems, who do you trust?

You chose the path of least disruption — **Track A**. Time to layer in observability.

Welcome to **Hybrid OT Integration**, the first track of the Pharma Factory Simulation.

This isn’t a rip-and-replace mission. It’s a surgical overlay — a way to weave **governance, memory, and reflex logic** into the systems you already run: DeltaV, HighByte, SCADA, MES. You’re not removing what works. You’re teaching it to remember.

## The Journey Ahead

Audit logs aren’t keeping up. Compliance is shifting — from paper trails to runtime guarantees. In Pharma, that memory gap isn’t just costly — it’s a compliance breach.

Open Industrial doesn’t disrupt your control layer. It overlays on top:

- **Observability** across legacy platforms
- **Passive schema ingestion** that translates OPC-UA or MQTT fields into governed structure — without touching the source
- **Reflex agents** that begin in shadow mode, quietly learning before they ever take action
- **Role-based visibility** for QA teams, engineers, and operations leadership

The reflex system is built to earn trust. Every signal it emits is traceable, testable, and exportable. You’re not replacing logic — you’re governing it, evolving it, and proving it live.

> “You’ll relive that failure — and teach the runtime how not to repeat it.”

## What You'll Layer On

Once connected, Open Industrial extends your plant runtime with:

- **Persistent memory** over legacy signals
- **Schema governance** to structure and version your observations
- **Audit trails** for reflex logic and agent behavior
- **Replays and diffs** that test reflexes against historical execution
- **Runtime policy files** (`runtime.policy.yaml`) that define promotion checkpoints
- **Role-based APIs** for saved views and domain-specific queries

> Reflexes are memory-bound function containers — authored in YAML or connected to embedded logic via FFI. They live alongside schemas, governed by runtime policy, versioned like source code.

A reflex is more than logic — it’s memory with motive. It doesn’t guess. It remembers, tests, and proves.

```txt
Reflex Lifecycle:
1. Observe – Shadow legacy data, no signal emission
2. Rehearse – Replay past impulses and track decision diffs
3. Align – Reflex memory aligns with trusted operator outcomes
4. Promote – reflex policy approves live execution
5. Drift – monitored and diffed continuously
```

That’s not theoretical. You’ll layer those exact primitives inside a real, observable zone — `LabZone-F`.

You’ll start by simulating memory. You’ll end with a reflex network that remembers more than your historian ever could.

```html
<figure class="my-16 flex flex-col items-center text-center max-w-xl w-full">
  <img
    src="/assets/docs/hybrid-reflex-flow.png"
    alt="Diagram showing reflex agents moving from audit-only to active mode based on replay trust."
    class="rounded-2xl shadow-2xl ring-1 ring-white/10 w-full"
  />
  <figcaption class="mt-4 text-sm text-gray-400 tracking-wide uppercase">
    Reflex lifecycle — from passive observer to promoted runtime controller.
  </figcaption>
</figure>

<figure class="my-16 flex flex-col items-center text-center max-w-xl w-full">
  <img
    src="/assets/docs/oi-overlay-stack.png"
    alt="Diagram showing Open Industrial overlaying an existing OT stack with schemas, reflexes, and memory."
    class="rounded-2xl shadow-2xl ring-1 ring-white/10 w-full"
  />
  <figcaption class="mt-4 text-sm text-gray-400 tracking-wide uppercase">
    Open Industrial overlays existing OT systems — no rip-and-replace. You author reflexes, memory, and governance on top.
  </figcaption>
</figure>

<figure class="my-16 flex flex-col items-center text-center max-w-xl w-full">
  <img
    src="/assets/docs/runtime-boundaries.png"
    alt="Diagram showing Open Industrial runtime sitting adjacent to legacy systems, with schema ingestion, reflex memory, and signal gates."
    class="rounded-2xl shadow-2xl ring-1 ring-white/10 w-full"
  />
  <figcaption class="mt-4 text-sm text-gray-400 tracking-wide uppercase">
    Trust boundaries: Open Industrial runs alongside — not inside — legacy systems. You own the memory and the logic.
  </figcaption>
</figure>
```

## The System Under Test

This factory failed compliance before. Now you’ll teach it to remember.

You’ll be working inside `LabZone-F`: a simulated cleanroom that manages environmental controls, batch pressure, and CIP cycles. Open Industrial begins in passive mode — observing telemetry, aligning schemas, and running agents in `audit-only` mode.

Every reflex begins as a witness. It earns the right to act.

Once replays align with historical behavior and memory is deemed trustworthy, reflexes are cleared to pass through the **governance gate** — and go live.

> “No reflex goes live until it has seen enough to remember — and remembered enough to act.”

## What You’ll Do

- Simulate memory over legacy signals
- Fork and evolve audit agents
- Replay history and diff reflex outcomes
- Ship production reflexes based on memory-backed proof

This is the **non-intrusive path** to runtime intelligence. It starts with observation. It ends with control — governed by memory, authored by your team.

```html
<aside class="border-l-4 border-neon-blue pl-4 italic text-neon-blue mt-4">
  Azi saw the signal that cleared — and the one that didn’t. The PLC didn’t. The historian didn’t. Which one would your auditor believe?
</aside>
```

## CLI Activation Points

With just a few commands, you’ll layer runtime memory over legacy signals — and start testing the reflexes your QA team has always needed:

```bash
# Fork a passive agent and test its memory alignment
oi agents fork cip-clean-audit --audit-only

# Replay historical data to validate logic
oi runtime replay cip-clean-room --since 7d --expect pass

# Promote the agent once governance criteria are met
oi agents promote cip-clean-audit-v1 --policy runtime.policy.yaml

# Visualize memory and agent trust status across the runtime
oi runtime show labzone-f --graph --trust
```

- `oi schemas import` — define structured overlays atop legacy tags
- `oi agents fork` — clone and extend passive agents into governed reflexes
- `oi runtime replay` — simulate past execution to test new logic safely

Reflexes only activate after they pass through the **governance gate** — a checkpoint defined in `runtime.policy.yaml` where memory proves itself.

> Reflex agents run inside the Open Industrial runtime — portable across nodes, sovereign to your infrastructure, and observable by your team.
> Surfaces define where memory is visualized or acted on — HMIs, APIs, even Grafana overlays.

> QA gets structured memory they can query. Ops gets reflex gates they can diff. Compliance gets runtime that explains itself.

This isn’t a new system. It’s a new layer of trust on the one you already operate.

> **“You didn’t rip and replace — you taught your system to remember.”**  
> **“In the old world, control logic disappeared after execution. Here, it’s remembered — diffed, promoted, and owned.”**
