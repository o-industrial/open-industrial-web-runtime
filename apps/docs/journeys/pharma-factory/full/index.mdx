# Full System Replacement – Author It All

_You chose the sovereign path. Track B begins now._

Welcome to **Track B** of the Pharma Factory Simulation — the bold path for sovereign builders ready to start from zero. This isn’t a layering exercise. It’s a full-stack runtime authored by you, with no legacy to appease and no vendor to please.

The goal? Build a complete pharmaceutical control system from first principles. Reflex logic. Audit-ready memory. Surfaces that execute. Policies that govern. And runtime that runs without supervision.

> "The next audit won’t ask what your HMI showed — it’ll ask what your system believed."

This isn’t a UI. It’s runtime belief, authored by you.

## Set the Tone

This track assumes nothing. You don’t start with an MES. You don’t inherit a vendor’s logic. You **author the runtime** — and you own it.

> The last batch failed QA. The reflex never triggered. No one knew why — until they opened the agent log.

In two months, your cleanroom will be audited. Can you prove your system evolved? Can you prove it remembered what you asked it to?

<aside class="border-l-4 border-yellow-400 pl-4 italic text-yellow-900 mt-4">
  You’re not shadowing legacy logic — you’re writing the law.
</aside>

## Define the Journey

In Track B, you’re not customizing around the edges — you’re creating the core. Every schema, every agent, every decision lives in open memory and can be inspected, forked, and improved.

You’ll build:

- A full runtime: surfaces, schemas, agents, logic
- Reflex memory that evolves with each promotion
- Private edge deployment: from rugged blades to air-gapped labs
- A Git-native workflow: team approvals, agent diffs, no lock-in

From the wiring layer up, you’ll define your system’s beliefs.

> Old world: vendor firmware and spreadsheet SOPs.  
> New world: explainable agents with reflex audit trails.

Your factory doesn’t flow in a pipeline — it thinks in loops. Sensors trigger reflexes. Reflexes act on zones. Zones log decisions. Memory evolves. Policy governs. And the next signal enters a smarter system.

Two months later, the factory passed its audit. CleanroomPressureGuard flagged a pressure spike — and Azi’s memory showed exactly why you let it pass.

## What You'll Build From Scratch

This journey starts with raw primitives. You’ll assemble:

- **Schema packs** as blueprints for environmental and batch control
- **Surfaces** as real execution zones: `Lab1`, `MixingZone`, `QA` — each a runtime host
- **Reflex agents** that enforce policy and interpret telemetry — starting with `CleanroomPressureGuard`
- **Reference memory** like `RoomConfig`, `DeviceRegistry`, and `BatchTargetSpec`

Everything is composable. Everything is yours.

> Every reflex you promote is forkable, inspectable, and traceable across teams.

## The System Simulated

This Pharma Factory is more than a demo — it's an operational simulation of a production-ready cleanroom control system:

- Reflexes control airflow, batch gates, QA thresholds, and pressure limits
- Memory retains decisions, thresholds, and promotion history
- Governance is enforced through signed policies and agent scope constraints

Each part of the system is:

- **Exportable** — runtime memory and policy can be rehydrated
- **Replayable** — impulses can be tested and validated
- **Forkable** — every schema and agent can evolve safely

```yaml
impulse: room3.temp > threshold
agent: CleanroomPressureGuard v1.2
action: adjust-valve:open
memory_log:
  - time: 04:31:02
    reflex: executed
    reason: updated RoomConfig.ref.temp.min
```

Every schema is a hypothesis. Every surface runs that hypothesis in the real world. Every agent turns feedback into action. Every action becomes memory — and your policy decides what evolves next.

<figure class="my-16 flex flex-col items-center text-center max-w-xl w-full">
  <img
    src="/assets/docs/pharma-factory-overview.png"
    alt="Diagram of the full-stack runtime structure built in Track B, showing schema packs, surfaces, agents, and policy modules."
    class="rounded-2xl shadow-2xl ring-1 ring-white/10 w-full"
  />
  <figcaption class="mt-4 text-sm text-neutral-400 tracking-wide uppercase">
    The full runtime stack: from schema to reflex to audit trail — evolving with every signal.
  </figcaption>
</figure>

## How to Start

Run your first reflex in 10 minutes:

- `oi packs install labzone-environment-pack pharma-pack`
- `oi surfaces create Lab1 QA MixingZone`
- `oi schemas promote` to lift reference schemas into your runtime
- `oi agents deploy` for reflex enforcement
- `oi runtime export --as forkable` to checkpoint and version memory
- Author your `runtime.policy.yaml` for drift governance and reflex scope

Want to skip the setup? Fork the Track B starter: [`github.com/openindustrial/pharma-factory-b`](https://github.com/openindustrial/pharma-factory-b)

```yaml
policy:
  reflex: CleanroomPressureGuard
  scope: ["MixingZone", "QA"]
  drift: log-only
  approval: team-leads
```
> Your reflex doesn’t just run. It runs *within contract* — versioned, scoped, governed.

<aside class="border-l-4 border-neon-blue pl-4 italic text-neon-blue mt-4">
  Azi remembers the first time RoomConfig drifted. You didn’t just accept it — you explained it. Now she logs that judgment every time it shifts.
</aside>

You didn’t just deploy logic. You authored belief.  
**And now your system remembers who taught it to think.**
