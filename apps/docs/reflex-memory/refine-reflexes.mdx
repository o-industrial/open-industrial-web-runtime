# Refine Your Reflexes

<div class="mt-6 mb-8 px-6 py-4 border-l-4 border-indigo-500 dark:border-indigo-400 bg-indigo-50 dark:bg-indigo-950 text-indigo-900 dark:text-indigo-100 rounded">
  <strong>Reflexes are not automation.</strong><br />
  They are your runtime’s belief system — versioned, observable, and alive.
</div>

RoomState v2 caught what v1 missed—quietly. Legacy pipelines would ship a patch, pray, and wait for staging to catch fire.

<aside class="border-l-4 border-rose-600 pl-4 italic text-rose-600">
Every legacy fix is a guess wrapped in a deployment. Every reflex fork is a proof, grounded in memory.
</aside>

Here, you fork, mock, and prove it — in memory.

This isn’t just replay. It’s intervention. Runtime doesn’t just tell you what happened — it invites you to change what happens next.

Now it’s your turn to fork, evolve, and test your changes **without risk**.

## Fork and Evolve Without Risk

Azi noticed FanControlAgent didn’t respond when humidity dipped — but RoomState v2 would have. She offers to fork it for you.

Open the **Agent Panel** → Click **Fork** → Name it `FanControlAgent v2`. This version will now be available for editing in a safe, testable environment.

You’ll edit the reflex logic to add new conditions — for example:
Only trigger the fan if humidity stays below 65% for two readings in a row.

From the **Surface Manager**, choose **LabZone-A**, then:
- Duplicate to a new SubSurface
- Enable mocking for `fan-control-001`
- Deploy `FanControlAgent v2` to this test space

Azi will replay recent impulses on both versions — your original and your fork.

She’ll then prompt you: “v1 triggered on impulse #88. v2 didn’t. Want to compare?”

In the **Impulse Diff View**, you'll see reflex behaviors side-by-side. If your update suppressed noisy signals or added smarter hysteresis — Azi will highlight the change.

<p><span class="font-semibold text-indigo-700 dark:text-indigo-300">CLI Tip:</span> Pull and diff your fork from terminal, if needed.</p>

Once the test results look solid, click **Promote** from the agent dropdown.

<figure class="my-16 flex flex-col items-center text-center max-w-xl w-full">
  <img src="/assets/docs/fork-modal-ui.png" alt="UI showing the forking of FanControlAgent to create v2." class="rounded-2xl shadow-2xl ring-1 ring-white/10 w-full" />
  <figcaption class="mt-4 text-sm text-neutral-400 tracking-wide uppercase">
    Fork any agent with full version lineage — no guesswork, no risk.
  </figcaption>
</figure>

Open the **Agent Panel** → Click **Fork** → Name it `FanControlAgent v2`.

<figure class="my-16 flex flex-col items-center text-center max-w-xl w-full">
  <img src="/assets/docs/mocked-surface-config.png" alt="Mocked surface configuration panel with actuators disabled." class="rounded-2xl shadow-2xl ring-1 ring-white/10 w-full" />
  <figcaption class="mt-4 text-sm text-neutral-400 tracking-wide uppercase">
    Deploy to a SubSurface to replay real history with safe, mocked outputs.
  </figcaption>
</figure>

From the **Surface Manager**, choose **LabZone-A**, then:
- Duplicate to a new SubSurface
- Enable mocking for `fan-control-001`
- Deploy `FanControlAgent v2` to this test space

<figure class="my-16 flex flex-col items-center text-center max-w-xl w-full">
  <img src="/assets/docs/impulse-diff-timeline.png" alt="Side-by-side impulse timeline comparing v1 and v2 agent responses." class="rounded-2xl shadow-2xl ring-1 ring-white/10 w-full" />
  <figcaption class="mt-4 text-sm text-neutral-400 tracking-wide uppercase">
    Diff agent responses across the same replay window — and choose confidently.
  </figcaption>
</figure>

Azi will replay recent impulses on both versions — your original and your fork. You’ll see exactly when FanControlAgent v2 held back — and how it reduced 6 unnecessary signals.

<figure class="my-16 flex flex-col items-center text-center max-w-xl w-full">
  <img src="/assets/docs/promotion-confirmation.png" alt="Confirmation modal for promoting FanControlAgent v2 to production." class="rounded-2xl shadow-2xl ring-1 ring-white/10 w-full" />
  <figcaption class="mt-4 text-sm text-neutral-400 tracking-wide uppercase">
    When your fork proves itself, promote it — and production adopts proven logic.
  </figcaption>
</figure>

## What Azi Observes

- After fork: “New logic fork created. Want to isolate it on a mocked surface?”
- After first impulse: “FanControlAgent v1 fired here. v2 didn’t. Want to diff?”
- Mid-replay: “Humidity dipped below 60%. v2 held back. Want to compare impact?”
- Before promotion: “v2 ran 17 impulses, fired 6 fewer signals. Want to promote it?”

<aside class="border-l-4 border-electric-purple pl-4 italic text-electric-purple">
This isn’t unit testing. It’s runtime epistemology. Your logic now lives in a memory-backed universe — provable, forkable, diffable.
</aside>

<aside class="border-l-4 border-electric-purple pl-4 italic text-electric-purple">
Legacy logic waits in staging. Reflexes learn in memory — and evolve in place.
</aside>

Every fork becomes part of your runtime lineage — traceable, reversible, and reusable.

<div class="mt-6 mb-8 px-6 py-4 border-l-4 border-indigo-500 dark:border-indigo-400 bg-indigo-50 dark:bg-indigo-950 text-indigo-900 dark:text-indigo-100 rounded">
  <strong>This isn’t a test layer.</strong><br />
  This is your runtime — forkable, introspectable, and governed by memory.
</div>

## Reflex Concepts You Now Own

- **Forks** hold lineage and versioned changes
- **SubSurfaces** replay real telemetry with safe mocks
- **Impulse Diffs** show comparative behavior, line by line
- **Lineage Tracking** ensures traceability and reversibility
- **Safe Promotion** lets you upgrade logic without guessing

<aside class="border-l-4 border-electric-purple pl-4 italic text-electric-purple">
CI/CD didn’t stop at deployment. Now it governs behavior. Reflex by reflex.
</aside>

<aside class="border-l-4 border-yellow-400 bg-yellow-50 pl-4 text-yellow-900">
📘 Haven’t built LabZone-A yet? Jump back to [4.1 – Unlock Reflex from Memory] to scaffold your surface.
</aside>

## 🧪 Your Turn

Fork `FanControlAgent` again — but this time, make it suppress the fan **entirely** when CO₂ levels exceed 800ppm. Use the `RoomState v2` schema. Then mock and diff it like before.

<aside class="border-l-4 border-electric-purple pl-4 italic text-electric-purple">
You’ve evolved reflexes. Now define the one your system never suggested.
</aside>

## What You’ve Proven

You didn’t just tune your reflex. You altered the system’s behavior in real memory — and proved it before it happened.

- You can evolve logic safely — and test it live without triggering real-world consequences
- You can replay actual telemetry into forked logic with full observability
- You can compare reflex deltas with audit-grade clarity
- You can govern runtime behavior reflex-by-reflex — no downtime, no guesswork
