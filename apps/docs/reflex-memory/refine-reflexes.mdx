# Refine Your Reflexes

You saw what the runtime remembered.  
Now it’s time to **change how it behaves** — without guessing.

Your logic failed silently — your runtime remembered. But will you?

RoomState v2 caught what v1 missed. But your agent didn’t respond — maybe it couldn’t yet.

You didn’t just replay history — you saw it differently. RoomState v2 exposed what your logic missed.

But replay doesn’t fix your reflex. You do. It’s time to shift from observation to intervention — from insight to action.

Now it’s your turn to fork, evolve, and test your changes **without risk**.

<aside class="border-l-4 border-neon-blue pl-4 italic text-neon-blue">
What if we delay the fan by 1 impulse? What if we suppress it under 65% humidity?  
You don’t have to guess. You can fork it, mock it, and prove it.
</aside>

## Fork and Evolve Without Risk

<aside class="border-l-4 border-yellow-400 bg-yellow-50 pl-4 text-yellow-900">
🛠 A SubSurface is a cloned execution environment where real telemetry is replayed but device commands are mocked — perfect for testing logic safely.
</aside>

<aside class="border-l-4 border-gray-300 bg-gray-50 text-gray-700 text-sm">
📎 <strong>Reminder:</strong> RoomState v2 includes: Temperature, Humidity, FanPower, and CO₂Level.
</aside>

<aside class="border-l-4 border-gray-300 bg-gray-50 text-gray-700 text-sm">
📎 <strong>CLI Tip:</strong> You can pull your agent fork locally to edit in your IDE:

```bash
openindustrial agents pull FanControlAgent-v2
```
</aside>

Reflexes aren’t static. You can version them, fork them, and replay their behavior — all without interrupting your live runtime. Here’s how:

> 🔧 **Run this now:**
> ```bash
> openindustrial agents fork FanControlAgent --name FanControlAgent-v2
> ```
> ✅ You just forked a live agent. Nothing broke. But something new just became testable.

> 🛠️ **Now try this:**
> Edit the logic in `FanControlAgent v2`. Add a rule like: "only trigger fan if humidity < 65% for 2 readings in a row."

> 🚀 **Deploy to mock environment:**
> ```bash
> openindustrial surfaces create LabZone-A-Test --mock fan-control-001
> openindustrial agents deploy FanControlAgent-v2 --surface LabZone-A-Test
> ```
> 💡 This SubSurface replays real impulses with safely mocked actuators.

> 🔍 **Compare results:**
> ```bash
> openindustrial impulse diff --agent FanControlAgent FanControlAgent-v2
> ```
> ```
> ⚙️  Impulse diff started...
> 📉  v1 triggered signal on humidity = 62%
> 🧠  v2 held back (humidity threshold = 65%)
> 🎯  Result: v2 triggered 6 fewer signals
> ```

<aside class="border-l-4 border-neon-blue pl-4 italic text-neon-blue">
What would happen if you delayed actuation until two low readings in a row? Try it in `FanControlAgent v2`. Replay and see.
</aside>

> ✅ **Promotion time?** If v2 proves safer or smarter, promote it:
> ```bash
> # Confirm promotion from CLI or UI modal
> ```

<figure class="my-16 flex flex-col items-center text-center max-w-xl w-full">
  <img
    src="/assets/docs/fork-modal-ui.png"
    alt="UI showing the forking of FanControlAgent to create v2."
    class="rounded-2xl shadow-2xl ring-1 ring-white/10 w-full"
  />
  <figcaption class="mt-4 text-sm text-gray-400 tracking-wide uppercase">
    Fork any agent with full version lineage — no guesswork, no risk.
  </figcaption>
</figure>

> 🛠️ **Now try this:**
> Edit the logic in `FanControlAgent v2`. Add a rule like: "only trigger fan if humidity < 65% for 2 readings in a row."

<figure class="my-16 flex flex-col items-center text-center max-w-xl w-full">
  <img
    src="/assets/docs/mocked-surface-config.png"
    alt="Mocked surface configuration panel with actuators disabled."
    class="rounded-2xl shadow-2xl ring-1 ring-white/10 w-full"
  />
  <figcaption class="mt-4 text-sm text-gray-400 tracking-wide uppercase">
    Deploy to a SubSurface to replay real history with safe, mocked outputs.
  </figcaption>
</figure>

> 🔍 **Compare results:**
> ```bash
> openindustrial impulse diff --agent FanControlAgent FanControlAgent-v2
> ```
> ```
> ⚙️  Impulse diff started...
> 📉  v1 triggered signal on humidity = 62%
> 🧠  v2 held back (humidity threshold = 65%)
> 🎯  Result: v2 triggered 6 fewer signals
> ```

<figure class="my-16 flex flex-col items-center text-center max-w-xl w-full">
  <img
    src="/assets/docs/impulse-diff-timeline.png"
    alt="Side-by-side impulse timeline comparing v1 and v2 agent responses."
    class="rounded-2xl shadow-2xl ring-1 ring-white/10 w-full"
  />
  <figcaption class="mt-4 text-sm text-gray-400 tracking-wide uppercase">
    Diff agent responses across the same replay window — and choose confidently.
  </figcaption>
</figure>

> ✅ **Promotion time?** If v2 proves safer or smarter, promote it:
> ```bash
> # Confirm promotion from CLI or UI modal
> ```

<figure class="my-16 flex flex-col items-center text-center max-w-xl w-full">
  <img
    src="/assets/docs/promotion-confirmation.png"
    alt="Confirmation modal for promoting FanControlAgent v2 to production."
    class="rounded-2xl shadow-2xl ring-1 ring-white/10 w-full"
  />
  <figcaption class="mt-4 text-sm text-gray-400 tracking-wide uppercase">
    When your fork proves itself, promote it — and production adopts proven logic.
  </figcaption>
</figure>

<aside class="border-l-4 border-yellow-400 bg-yellow-50 pl-4 text-yellow-900">
Want to run this as a GitHub Action before promotion? Try:

```bash
openindustrial replay --expect
```
</aside>

<aside class="border-l-4 border-electric-purple pl-4 italic text-electric-purple">
Reflex forking isn’t just safer logic. It’s the basis for adaptive runtime architecture — one where logic evolves in memory, not in pull requests.
</aside>

<aside class="border-l-4 border-rose-600 pl-4 italic text-rose-600">
You used to write reflex changes, ship to staging, pray for test coverage, and hope you didn’t break production. Now you just fork, mock, and prove it — in real memory.
</aside>

## What Azi Observes

- After fork: “New logic fork created. Want to isolate it on a mocked surface?”
- After first impulse: “FanControlAgent v1 fired here. v2 didn’t. Want to diff?”
- Mid-replay: “Humidity dipped below 60%. v2 held back. Want to compare impact?”
- Before promotion: “v2 ran 17 impulses, fired 6 fewer signals. Want to promote it?”

<aside class="border-l-4 border-electric-purple pl-4 italic text-electric-purple">
This isn’t unit testing. It’s runtime epistemology. Your logic now lives in a memory-backed universe — provable, forkable, diffable.
</aside>

<aside class="border-l-4 border-electric-purple pl-4 italic text-electric-purple">
Legacy logic waits in staging. Reflexes learn in memory — and evolve in place.
</aside>

## Reflex Concepts You Now Own

- **Forks** hold lineage and versioned changes
- **SubSurfaces** replay real telemetry with safe mocks
- **Impulse Diffs** show comparative behavior, line by line
- **Lineage Tracking** ensures traceability and reversibility
- **Safe Promotion** lets you upgrade logic without guessing

<aside class="border-l-4 border-electric-purple pl-4 italic text-electric-purple">
CI/CD didn’t stop at deployment.  
Now it governs behavior. Reflex by reflex.
</aside>

<aside class="border-l-4 border-yellow-400 bg-yellow-50 pl-4 text-yellow-900">
📘 Haven’t built LabZone-A yet? Jump back to [4.1 – Unlock Reflex from Memory] to scaffold your surface.
</aside>

## 🧪 Your Turn

<aside class="border-l-4 border-electric-purple pl-4 italic text-electric-purple">
You’ve proven you can evolve reflexes. Now let’s see if you can invent them — from scratch.
</aside>

Fork `FanControlAgent` again — but this time, make it suppress the fan **entirely** when CO₂ levels exceed 800ppm.  
Hint: Use the `RoomState v2` schema. Then mock and diff it like before.

<aside class="border-l-4 border-electric-purple pl-4 italic text-electric-purple">
Next up: What if this reflex didn’t exist yet? What if Azi didn’t suggest it? What if you authored it entirely yourself?
</aside>

## What You’ve Proven

You didn’t just tune your reflex. You altered the system’s behavior in real memory — and proved it before it happened.

- You can evolve logic safely — and test it live without triggering real-world consequences
- You can replay actual telemetry into forked logic with full observability
- You can compare reflex deltas with audit-grade clarity
- You can govern runtime behavior reflex-by-reflex — no downtime, no guesswork
