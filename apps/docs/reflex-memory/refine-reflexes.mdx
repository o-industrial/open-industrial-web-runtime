# Refine Your Reflexes

You saw what the runtime remembered.  
Now itâ€™s time to **change how it behaves** â€” without guessing.

Your logic failed silently â€” your runtime remembered. But will you?

RoomState v2 caught what v1 missed. But your agent didnâ€™t respond â€” maybe it couldnâ€™t yet.

You didnâ€™t just replay history â€” you saw it differently. RoomState v2 exposed what your logic missed.

But replay doesnâ€™t fix your reflex. You do. Itâ€™s time to shift from observation to intervention â€” from insight to action.

Now itâ€™s your turn to fork, evolve, and test your changes **without risk**.

<aside class="border-l-4 border-neon-blue pl-4 italic text-neon-blue">
What if we delay the fan by 1 impulse? What if we suppress it under 65% humidity?  
You donâ€™t have to guess. You can fork it, mock it, and prove it.
</aside>

## Fork and Evolve Without Risk

<aside class="border-l-4 border-yellow-400 bg-yellow-50 pl-4 text-yellow-900">
ğŸ›  A SubSurface is a cloned execution environment where real telemetry is replayed but device commands are mocked â€” perfect for testing logic safely.
</aside>

<aside class="border-l-4 border-gray-300 bg-gray-50 text-gray-700 text-sm">
ğŸ“ <strong>Reminder:</strong> RoomState v2 includes: Temperature, Humidity, FanPower, and COâ‚‚Level.
</aside>

<aside class="border-l-4 border-gray-300 bg-gray-50 text-gray-700 text-sm">
ğŸ“ <strong>CLI Tip:</strong> You can pull your agent fork locally to edit in your IDE:

```bash
openindustrial agents pull FanControlAgent-v2
```
</aside>

Reflexes arenâ€™t static. You can version them, fork them, and replay their behavior â€” all without interrupting your live runtime. Hereâ€™s how:

> ğŸ”§ **Run this now:**
> ```bash
> openindustrial agents fork FanControlAgent --name FanControlAgent-v2
> ```
> âœ… You just forked a live agent. Nothing broke. But something new just became testable.

> ğŸ› ï¸ **Now try this:**
> Edit the logic in `FanControlAgent v2`. Add a rule like: "only trigger fan if humidity < 65% for 2 readings in a row."

> ğŸš€ **Deploy to mock environment:**
> ```bash
> openindustrial surfaces create LabZone-A-Test --mock fan-control-001
> openindustrial agents deploy FanControlAgent-v2 --surface LabZone-A-Test
> ```
> ğŸ’¡ This SubSurface replays real impulses with safely mocked actuators.

> ğŸ” **Compare results:**
> ```bash
> openindustrial impulse diff --agent FanControlAgent FanControlAgent-v2
> ```
> ```
> âš™ï¸  Impulse diff started...
> ğŸ“‰  v1 triggered signal on humidity = 62%
> ğŸ§   v2 held back (humidity threshold = 65%)
> ğŸ¯  Result: v2 triggered 6 fewer signals
> ```

<aside class="border-l-4 border-neon-blue pl-4 italic text-neon-blue">
What would happen if you delayed actuation until two low readings in a row? Try it in `FanControlAgent v2`. Replay and see.
</aside>

> âœ… **Promotion time?** If v2 proves safer or smarter, promote it:
> ```bash
> # Confirm promotion from CLI or UI modal
> ```

<figure class="my-16 flex flex-col items-center text-center max-w-xl w-full">
  <img
    src="/assets/docs/fork-modal-ui.png"
    alt="UI showing the forking of FanControlAgent to create v2."
    class="rounded-2xl shadow-2xl ring-1 ring-white/10 w-full"
  />
  <figcaption class="mt-4 text-sm text-gray-400 tracking-wide uppercase">
    Fork any agent with full version lineage â€” no guesswork, no risk.
  </figcaption>
</figure>

> ğŸ› ï¸ **Now try this:**
> Edit the logic in `FanControlAgent v2`. Add a rule like: "only trigger fan if humidity < 65% for 2 readings in a row."

<figure class="my-16 flex flex-col items-center text-center max-w-xl w-full">
  <img
    src="/assets/docs/mocked-surface-config.png"
    alt="Mocked surface configuration panel with actuators disabled."
    class="rounded-2xl shadow-2xl ring-1 ring-white/10 w-full"
  />
  <figcaption class="mt-4 text-sm text-gray-400 tracking-wide uppercase">
    Deploy to a SubSurface to replay real history with safe, mocked outputs.
  </figcaption>
</figure>

> ğŸ” **Compare results:**
> ```bash
> openindustrial impulse diff --agent FanControlAgent FanControlAgent-v2
> ```
> ```
> âš™ï¸  Impulse diff started...
> ğŸ“‰  v1 triggered signal on humidity = 62%
> ğŸ§   v2 held back (humidity threshold = 65%)
> ğŸ¯  Result: v2 triggered 6 fewer signals
> ```

<figure class="my-16 flex flex-col items-center text-center max-w-xl w-full">
  <img
    src="/assets/docs/impulse-diff-timeline.png"
    alt="Side-by-side impulse timeline comparing v1 and v2 agent responses."
    class="rounded-2xl shadow-2xl ring-1 ring-white/10 w-full"
  />
  <figcaption class="mt-4 text-sm text-gray-400 tracking-wide uppercase">
    Diff agent responses across the same replay window â€” and choose confidently.
  </figcaption>
</figure>

> âœ… **Promotion time?** If v2 proves safer or smarter, promote it:
> ```bash
> # Confirm promotion from CLI or UI modal
> ```

<figure class="my-16 flex flex-col items-center text-center max-w-xl w-full">
  <img
    src="/assets/docs/promotion-confirmation.png"
    alt="Confirmation modal for promoting FanControlAgent v2 to production."
    class="rounded-2xl shadow-2xl ring-1 ring-white/10 w-full"
  />
  <figcaption class="mt-4 text-sm text-gray-400 tracking-wide uppercase">
    When your fork proves itself, promote it â€” and production adopts proven logic.
  </figcaption>
</figure>

<aside class="border-l-4 border-yellow-400 bg-yellow-50 pl-4 text-yellow-900">
Want to run this as a GitHub Action before promotion? Try:

```bash
openindustrial replay --expect
```
</aside>

<aside class="border-l-4 border-electric-purple pl-4 italic text-electric-purple">
Reflex forking isnâ€™t just safer logic. Itâ€™s the basis for adaptive runtime architecture â€” one where logic evolves in memory, not in pull requests.
</aside>

<aside class="border-l-4 border-rose-600 pl-4 italic text-rose-600">
You used to write reflex changes, ship to staging, pray for test coverage, and hope you didnâ€™t break production. Now you just fork, mock, and prove it â€” in real memory.
</aside>

## What Azi Observes

- After fork: â€œNew logic fork created. Want to isolate it on a mocked surface?â€
- After first impulse: â€œFanControlAgent v1 fired here. v2 didnâ€™t. Want to diff?â€
- Mid-replay: â€œHumidity dipped below 60%. v2 held back. Want to compare impact?â€
- Before promotion: â€œv2 ran 17 impulses, fired 6 fewer signals. Want to promote it?â€

<aside class="border-l-4 border-electric-purple pl-4 italic text-electric-purple">
This isnâ€™t unit testing. Itâ€™s runtime epistemology. Your logic now lives in a memory-backed universe â€” provable, forkable, diffable.
</aside>

<aside class="border-l-4 border-electric-purple pl-4 italic text-electric-purple">
Legacy logic waits in staging. Reflexes learn in memory â€” and evolve in place.
</aside>

## Reflex Concepts You Now Own

- **Forks** hold lineage and versioned changes
- **SubSurfaces** replay real telemetry with safe mocks
- **Impulse Diffs** show comparative behavior, line by line
- **Lineage Tracking** ensures traceability and reversibility
- **Safe Promotion** lets you upgrade logic without guessing

<aside class="border-l-4 border-electric-purple pl-4 italic text-electric-purple">
CI/CD didnâ€™t stop at deployment.  
Now it governs behavior. Reflex by reflex.
</aside>

<aside class="border-l-4 border-yellow-400 bg-yellow-50 pl-4 text-yellow-900">
ğŸ“˜ Havenâ€™t built LabZone-A yet? Jump back to [4.1 â€“ Unlock Reflex from Memory] to scaffold your surface.
</aside>

## ğŸ§ª Your Turn

<aside class="border-l-4 border-electric-purple pl-4 italic text-electric-purple">
Youâ€™ve proven you can evolve reflexes. Now letâ€™s see if you can invent them â€” from scratch.
</aside>

Fork `FanControlAgent` again â€” but this time, make it suppress the fan **entirely** when COâ‚‚ levels exceed 800ppm.  
Hint: Use the `RoomState v2` schema. Then mock and diff it like before.

<aside class="border-l-4 border-electric-purple pl-4 italic text-electric-purple">
Next up: What if this reflex didnâ€™t exist yet? What if Azi didnâ€™t suggest it? What if you authored it entirely yourself?
</aside>

## What Youâ€™ve Proven

You didnâ€™t just tune your reflex. You altered the systemâ€™s behavior in real memory â€” and proved it before it happened.

- You can evolve logic safely â€” and test it live without triggering real-world consequences
- You can replay actual telemetry into forked logic with full observability
- You can compare reflex deltas with audit-grade clarity
- You can govern runtime behavior reflex-by-reflex â€” no downtime, no guesswork
