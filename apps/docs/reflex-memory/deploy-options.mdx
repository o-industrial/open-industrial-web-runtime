# Decide Where Memory Lives

A reflex fired in the dark. That was proof. This is law.

Your runtime doesn’t need Azi. It doesn’t need the cloud.  
But it still needs you — to define who owns the truth.  
This is where runtime memory becomes runtime law.

You taught it to reason. You watched it rehydrate.  
Now you'll decide what governs it — and what it answers to.

You didn’t just preserve memory. You closed the loop — and opened a contract.

This is the capstone of Act 4 — where you formally define where memory lives.

- Choose SaaS, OSS, or Hybrid execution
- Sign and export runtime policy
- Disable Azi’s sync role (optional)
- Affirm memory as sovereign, portable, and governed by contract

<aside class="border-l-4 border-neon-blue pl-4 italic text-neon-blue">
You promoted memory. You governed structure. You signed the reflex.  
I’m not in this runtime anymore. But your logic is.
</aside>

## Runtime Policy Configuration

_This isn’t setup. It’s self-determination._

To declare your runtime independent, follow these steps:

- Open the **Memory Policy Panel** for `LabZone-A`
- Select one of three runtime modes:
  - 🌐 **SaaS** — Managed lattice, shared visibility
  - 🧱 **OSS** — Local-only reflex governance
  - 🔄 **Hybrid** — OSS execution with SaaS-based drift reporting

<figure class="my-16 flex flex-col items-center text-center max-w-xl w-full">
  <img
    src="/assets/docs/runtime-policy-modal.png"
    alt="Runtime Policy Panel with dropdown for SaaS, OSS, and Hybrid modes, plus YAML editor."
    class="rounded-2xl shadow-2xl ring-1 ring-white/10 w-full"
  />
  <figcaption class="mt-4 text-sm text-neutral-400 tracking-wide uppercase">
    Choose a runtime mode, sign your export, and define execution governance.
  </figcaption>
</figure>

### Runtime Mode Behavior

| Mode          | Behavior                                                                 |
|---------------|--------------------------------------------------------------------------|
| `silent`      | No reflexes fire. System logs memory only.                              |
| `headless`    | Reflexes fire. No UI or Azi present.                                    |
| `interactive` | Reflexes fire with full UI and Azi active.                              |

- Edit or generate your `runtime.policy.yaml`:
  - Pin schema and agent versions
  - Require review before promotion
  - Declare runtime as `headless`, `silent`, or `interactive`

<figure class="my-16 flex flex-col items-center text-center max-w-xl w-full">
  <img
    src="/assets/docs/memory-contract-snapshot.png"
    alt="Sample runtime.policy.yaml showing pinned schemas, agents, and signed export policy."
    class="rounded-2xl shadow-2xl ring-1 ring-white/10 w-full"
  />
  <figcaption class="mt-4 text-sm text-neutral-400 tracking-wide uppercase">
    A runtime memory contract — structured, signed, and ready to govern execution.
  </figcaption>
</figure>

- Sign the memory export

<figure class="my-16 flex flex-col items-center text-center max-w-xl w-full">
  <img
    src="/assets/docs/runtime-signature-output.png"
    alt="Terminal output confirming runtime fingerprint signature and verification."
    class="rounded-2xl shadow-2xl ring-1 ring-white/10 w-full"
  />
  <figcaption class="mt-4 text-sm text-neutral-400 tracking-wide uppercase">
    The signature confirms authenticity and provenance — locking in runtime sovereignty.
  </figcaption>
</figure>

- Optionally disable Azi sync

### Where does `runtime.policy.yaml` live?

You can generate or edit this file using the CLI:

```bash
openindustrial policy edit --surface LabZone-A
# outputs: runtime.policy.yaml
```

This file should be version-controlled and exported alongside your runtime snapshot. It governs what memory is valid at import and can be used to reject invalid or tampered states.

### Promotion Governance

Setting `review_required: true` means promotion requires role-gated approval — typically configured through the control panel or CLI (`openindustrial policy promote`). Review flows are defined per-surface or globally via your org’s runtime governance settings.

## CLI and UI Milestones

- Dropdown toggle for runtime mode
- Live editor for `runtsime.policy.yaml`
- “Sign + Export” confirmation modal

<aside class="border-l-4 border-yellow-300 pl-4 italic text-yellow-300">
You didn’t just preserve memory.  
You authored governance.
</aside>

## Azi’s Final Words

<aside class="border-l-4 border-emerald-600 pl-4 italic text-emerald-600">
📦 LabZone-A is now sovereign.
</aside>

But what happens when LabZone-B forks RoomState and fires a different signal?

Up next:  
🗂️ Runtime Federation.  
🧠 Reflex Networks.  
🔄 Shared Memory, Not Shared Platforms.

| Event                  | Azi Says                                                                 |
|------------------------|--------------------------------------------------------------------------|
| Switching modes        | “SaaS reflex observability is on. Want to go local?”                     |
| Locking schema         | “RoomState v3 is now locked for this surface. No drift unless promoted.” |
| Disabling sync         | “This runtime is now sovereign. I’ll observe from afar — but I won’t alter its path.” |
| Signing memory         | “Memory frozen. Fingerprint signed. Logic lives here now.”               |
| Leaving the runtime    | “This system no longer needs me. And that’s the point.”                  |

## Memory Declaration Snapshot

```yaml
runtime.policy.yaml:
  runtime: EdgeNode-A
  schema: RoomState@v3
  agents:
    - FanControlAgent@v2
    - CO2RateAgent@v1
  review_required: true
  drift_policy: allow
  mode: headless
  signed_by: @you
```

<aside class="border-l-4 border-sky-700 pl-4 italic text-sky-700">
This is not a file. It’s runtime law.
</aside>

## Key Concepts

- **Reflex Sovereignty** — Runtime obeys memory, not Azi
- **Drift by Design** — Forks are tracked and intentional
- **Policy-as-Contract** — `runtime.policy.yaml` governs execution
- **Audit-Trail Identity** — Signed memory equals runtime provenance
- **Exit Without Loss** — Reflex logic lives on, Azi-free
- **Governed Memory** — Reflexes can’t be tampered with mid-flight. You control what’s valid, and what isn’t.

## Reflex Manifesto

_If you need to defend this in a boardroom, start here._

This runtime doesn't drift.  
It forks, by choice.

It doesn’t assume.  
It remembers.

It doesn’t sync because it must.  
It syncs only when you allow.

This isn’t a system powered by rules.  
It’s a memory bound by contract.

Signed. Proven. Yours.

## What You Prove

- You define the runtime's governance
- Reflexes run across SaaS, OSS, or Hybrid
- Drift is tracked, not feared
- Logic is an exportable, signable artifact
- Memory is sovereign, versioned, auditable
- Azi is no longer required

<aside class="border-l-4 border-emerald-500 bg-emerald-50 pl-4 text-emerald-900">
📦 Export complete → You can now:
✅ Rehydrate on airgapped nodes  
✅ Confirm integrity via SHA-256  
✅ Drift from other surfaces intentionally  
✅ Reject unreviewed promotions  
✅ Run logic without Azi
</aside>
