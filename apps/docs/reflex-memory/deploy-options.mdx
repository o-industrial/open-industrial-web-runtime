# Decide Where Memory Lives

A reflex fired in the dark. That was proof. This is law.

Your runtime doesnâ€™t need Azi. It doesnâ€™t need the cloud.  
But it still needs you â€” to define who owns the truth.  
This is where runtime memory becomes runtime law.

You taught it to reason. You watched it rehydrate.  
Now you'll decide what governs it â€” and what it answers to.

You didnâ€™t just preserve memory. You closed the loop â€” and opened a contract.

This is the capstone of Act 4 â€” where you formally define where memory lives.

- Choose SaaS, OSS, or Hybrid execution
- Sign and export runtime policy
- Disable Aziâ€™s sync role (optional)
- Affirm memory as sovereign, portable, and governed by contract

<aside class="border-l-4 border-neon-blue pl-4 italic text-neon-blue">
You promoted memory. You governed structure. You signed the reflex.  
Iâ€™m not in this runtime anymore. But your logic is.
</aside>

## Runtime Policy Configuration

_This isnâ€™t setup. Itâ€™s self-determination._

To declare your runtime independent, follow these steps:

- Open the **Memory Policy Panel** for `LabZone-A`
- Select one of three runtime modes:
  - ğŸŒ **SaaS** â€” Managed lattice, shared visibility
  - ğŸ§± **OSS** â€” Local-only reflex governance
  - ğŸ”„ **Hybrid** â€” OSS execution with SaaS-based drift reporting

<figure class="my-16 flex flex-col items-center text-center max-w-xl w-full">
  <img
    src="/assets/docs/runtime-policy-modal.png"
    alt="Runtime Policy Panel with dropdown for SaaS, OSS, and Hybrid modes, plus YAML editor."
    class="rounded-2xl shadow-2xl ring-1 ring-white/10 w-full"
  />
  <figcaption class="mt-4 text-sm text-neutral-400 tracking-wide uppercase">
    Choose a runtime mode, sign your export, and define execution governance.
  </figcaption>
</figure>

### Runtime Mode Behavior

| Mode          | Behavior                                                                 |
|---------------|--------------------------------------------------------------------------|
| `silent`      | No reflexes fire. System logs memory only.                              |
| `headless`    | Reflexes fire. No UI or Azi present.                                    |
| `interactive` | Reflexes fire with full UI and Azi active.                              |

- Edit or generate your `runtime.policy.yaml`:
  - Pin schema and agent versions
  - Require review before promotion
  - Declare runtime as `headless`, `silent`, or `interactive`

<figure class="my-16 flex flex-col items-center text-center max-w-xl w-full">
  <img
    src="/assets/docs/memory-contract-snapshot.png"
    alt="Sample runtime.policy.yaml showing pinned schemas, agents, and signed export policy."
    class="rounded-2xl shadow-2xl ring-1 ring-white/10 w-full"
  />
  <figcaption class="mt-4 text-sm text-neutral-400 tracking-wide uppercase">
    A runtime memory contract â€” structured, signed, and ready to govern execution.
  </figcaption>
</figure>

- Sign the memory export

<figure class="my-16 flex flex-col items-center text-center max-w-xl w-full">
  <img
    src="/assets/docs/runtime-signature-output.png"
    alt="Terminal output confirming runtime fingerprint signature and verification."
    class="rounded-2xl shadow-2xl ring-1 ring-white/10 w-full"
  />
  <figcaption class="mt-4 text-sm text-neutral-400 tracking-wide uppercase">
    The signature confirms authenticity and provenance â€” locking in runtime sovereignty.
  </figcaption>
</figure>

- Optionally disable Azi sync

### Where does `runtime.policy.yaml` live?

You can generate or edit this file using the CLI:

```bash
openindustrial policy edit --surface LabZone-A
# outputs: runtime.policy.yaml
```

This file should be version-controlled and exported alongside your runtime snapshot. It governs what memory is valid at import and can be used to reject invalid or tampered states.

### Promotion Governance

Setting `review_required: true` means promotion requires role-gated approval â€” typically configured through the control panel or CLI (`openindustrial policy promote`). Review flows are defined per-surface or globally via your orgâ€™s runtime governance settings.

## CLI and UI Milestones

- Dropdown toggle for runtime mode
- Live editor for `runtsime.policy.yaml`
- â€œSign + Exportâ€ confirmation modal

<aside class="border-l-4 border-yellow-300 pl-4 italic text-yellow-300">
You didnâ€™t just preserve memory.  
You authored governance.
</aside>

## Aziâ€™s Final Words

<aside class="border-l-4 border-emerald-600 pl-4 italic text-emerald-600">
ğŸ“¦ LabZone-A is now sovereign.
</aside>

But what happens when LabZone-B forks RoomState and fires a different signal?

Up next:  
ğŸ—‚ï¸ Runtime Federation.  
ğŸ§  Reflex Networks.  
ğŸ”„ Shared Memory, Not Shared Platforms.

| Event                  | Azi Says                                                                 |
|------------------------|--------------------------------------------------------------------------|
| Switching modes        | â€œSaaS reflex observability is on. Want to go local?â€                     |
| Locking schema         | â€œRoomState v3 is now locked for this surface. No drift unless promoted.â€ |
| Disabling sync         | â€œThis runtime is now sovereign. Iâ€™ll observe from afar â€” but I wonâ€™t alter its path.â€ |
| Signing memory         | â€œMemory frozen. Fingerprint signed. Logic lives here now.â€               |
| Leaving the runtime    | â€œThis system no longer needs me. And thatâ€™s the point.â€                  |

## Memory Declaration Snapshot

```yaml
runtime.policy.yaml:
  runtime: EdgeNode-A
  schema: RoomState@v3
  agents:
    - FanControlAgent@v2
    - CO2RateAgent@v1
  review_required: true
  drift_policy: allow
  mode: headless
  signed_by: @you
```

<aside class="border-l-4 border-sky-700 pl-4 italic text-sky-700">
This is not a file. Itâ€™s runtime law.
</aside>

## Key Concepts

- **Reflex Sovereignty** â€” Runtime obeys memory, not Azi
- **Drift by Design** â€” Forks are tracked and intentional
- **Policy-as-Contract** â€” `runtime.policy.yaml` governs execution
- **Audit-Trail Identity** â€” Signed memory equals runtime provenance
- **Exit Without Loss** â€” Reflex logic lives on, Azi-free
- **Governed Memory** â€” Reflexes canâ€™t be tampered with mid-flight. You control whatâ€™s valid, and what isnâ€™t.

## Reflex Manifesto

_If you need to defend this in a boardroom, start here._

This runtime doesn't drift.  
It forks, by choice.

It doesnâ€™t assume.  
It remembers.

It doesnâ€™t sync because it must.  
It syncs only when you allow.

This isnâ€™t a system powered by rules.  
Itâ€™s a memory bound by contract.

Signed. Proven. Yours.

## What You Prove

- You define the runtime's governance
- Reflexes run across SaaS, OSS, or Hybrid
- Drift is tracked, not feared
- Logic is an exportable, signable artifact
- Memory is sovereign, versioned, auditable
- Azi is no longer required

<aside class="border-l-4 border-emerald-500 bg-emerald-50 pl-4 text-emerald-900">
ğŸ“¦ Export complete â†’ You can now:
âœ… Rehydrate on airgapped nodes  
âœ… Confirm integrity via SHA-256  
âœ… Drift from other surfaces intentionally  
âœ… Reject unreviewed promotions  
âœ… Run logic without Azi
</aside>
