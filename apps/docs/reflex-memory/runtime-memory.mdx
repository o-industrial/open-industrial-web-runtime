# See What the Runtime Remembers

Once your system has been running â€” surfaces streaming, reflexes firing â€” the real power comes not just from what happens, but from whatâ€™s remembered.

> _â€œYour fan didnâ€™t trigger. Was it a threshold miss â€” or a structure failure?â€_

History isnâ€™t fixed â€” not when structure arrives after the fact.

RoomState v2 didnâ€™t exist when your first data arrived. But Azi was watching. Now, with structure in place, sheâ€™s ready to show you what *shouldâ€™ve* happened.

This isnâ€™t just telemetry review. This is **structure-aware hindsight.** A runtime black box. A second sight.

Youâ€™ll use replay not to restore â€” but to reveal. Not to duplicate â€” but to understand.

<aside class="border-l-4 border-electric-purple pl-4 italic text-electric-purple">
This isnâ€™t replay. Itâ€™s runtime testimony.
</aside>

<aside class="border-l-4 border-neutral-300 bg-neutral-50 text-neutral-700 text-sm">
ğŸ“˜ <strong>Note:</strong> A signal is a named output from a reflex agent â€” typically an action like <code>Fan.On</code> or <code>Alert.Raise</code>.
</aside>

<aside class="border-l-4 border-electric-purple pl-4 italic text-electric-purple">
Every impulse is a contract. Replay is how you audit it.
</aside>

---

## ğŸ§ª Step 1: Inspect Runtime Memory

Open the **Runtime Reflex Panel** on the LabZone-A surface.

- Find it under **Surface â†’ Reflex View**.
- Azi shows:
  - Bound schemas
  - Recently triggered reflex agents
  - Timeline toggle: ğŸ“Š *Live View* | ğŸ” *Replay View*

Switch to *Replay View*.

---

## ğŸ§ª Step 2: Preview Impulses to Replay

Before Azi prompts, you can manually inspect available impulses:

<aside class="border-l-4 border-neutral-300 bg-neutral-50 text-neutral-700 text-sm">
ğŸ“ <strong>CLI Tip:</strong> Use this to preview impulse ranges:

```bash
openindustrial surface impulses --surface LabZone-A
```
</aside>

Youâ€™ll see entries like:
```txt
Impulse #88: Temp = 84.7Â°F
Impulse #89: Temp = 85.2Â°F
Impulse #90: Temp = 85.6Â°F
...
Impulse #112: Temp = 84.1Â°F
```

<aside class="border-l-4 border-electric-purple pl-4 italic text-electric-purple">
An impulse isnâ€™t just telemetry â€” itâ€™s time, memory, and logic, all bound to one structural frame.
</aside>

---

## ğŸ§ª Step 3: Trigger Replay Prompt

If `RoomState v2` was promoted **after** telemetry began, Azi will prompt:

<aside class="border-l-4 border-neon-blue pl-4 italic text-neon-blue">
â€œRoomState v2 was promoted after these impulses arrived.  
Want to rehydrate history â€” and see what wouldâ€™ve triggered?â€
</aside>

<figure class="my-16 flex flex-col items-center text-center max-w-xl w-full">
  <img
    src="/assets/docs/impulse-diff-signal-map.png"
    alt="Impulse diff showing v1 with no signal and v2 triggering Fan.On."
    class="rounded-2xl shadow-2xl ring-1 ring-white/10 w-full"
  />
  <figcaption class="mt-4 text-sm text-neutral-400 tracking-wide uppercase">
    Impulse Diff: What RoomState v1 missed â€” and v2 caught.
  </figcaption>
</figure>

<aside class="border-l-4 border-neutral-300 bg-neutral-50 text-neutral-700 text-sm">
ğŸ“ <strong>CLI Starter:</strong> Try the built-in test replay scenario:

```bash
openindustrial replay plan --example fan-scenario
```
</aside>

Choose your replay scope:
- **From Binding** *(default)*
- **From Surface Creation**
- **From Historical Connection Log**

Preview will show:
- Impulse range (e.g. #88â€“112)
- Recreated `RoomState` entries
- Reflex signals (dry-run only)

```bash
openindustrial impulse diff \
  --schema RoomState \
  --impulse 90 \
  --compare roomstate@v1 roomstate@v2
```

```txt
Impulse #90 (Temp = 85.6Â°F)
v1 â†’ No signal  
v2 â†’ FanControlAgent â†’ Signal: Fan.On
```

<aside class="border-l-4 border-neon-blue pl-4 italic text-neon-blue">
RoomTargetConfig wasnâ€™t there yet. But now that it is, FanControlAgent has context.
</aside>

<aside class="border-l-4 border-yellow-400 bg-yellow-50 pl-4 text-yellow-900">
Without this replay, youâ€™d never know RoomState v1 was underfiring â€” or that RoomState v2 wouldâ€™ve prevented it.
</aside>

<aside class="border-l-4 border-neon-blue pl-4 italic text-neon-blue">
â€œThis signal didnâ€™t fire. You didnâ€™t see it. But RoomState v2 would have.â€
</aside>

<aside class="border-l-4 border-neon-blue pl-4 italic text-neon-blue">
â€œRoomState v2 caught what v1 missed. Want to fork FanControlAgent and evolve the logic?â€
</aside>

---

## ğŸ§ª Step 4: Review Replay Types

<aside class="border-l-4 border-yellow-400 bg-yellow-50 pl-4 text-yellow-900">
ğŸ’¡ Replay is idempotent by default: it fills structure but doesnâ€™t trigger signals.
</aside>

| Replay Mode | Effect |
|-------------|--------|
| ğŸ— Schema Replay | Memory only â€” no logic re-evaluation |
| âš™ï¸ Reflex Dry Run | Show what wouldâ€™ve fired (no action) |
| ğŸš¨ Signal Commit | *Optional.* Replay triggers signals again â€” only if reflex logic evaluates to a change. |

<aside class="border-l-4 border-neon-blue pl-4 italic text-neon-blue">
â€œEven with Signal Commit, reflex agents wonâ€™t re-fire unless memory or conditions have changed.â€
</aside>

<aside class="border-l-4 border-electric-purple pl-4 italic text-electric-purple">
This isnâ€™t a replay of events. Itâ€™s a memory audit of how your structure wouldâ€™ve seen them.
</aside>

<aside class="border-l-4 border-electric-purple pl-4 italic text-electric-purple">
Replay dry-runs arenâ€™t just educational â€” theyâ€™re **CI-grade introspection**.  
Use them in PR checks to validate schema updates against real-world impulse history.
</aside>

<figure class="my-16 flex flex-col items-center text-center max-w-xl w-full">
  <img
    src="/assets/docs/ci-replay-hook.png"
    alt="Diagram of CI workflow using replay to validate schema changes."
    class="rounded-2xl shadow-2xl ring-1 ring-white/10 w-full"
  />
  <figcaption class="mt-4 text-sm text-neutral-400 tracking-wide uppercase">
    CI Hook: Run replay dry-runs on every pull request.
  </figcaption>
</figure>

---

## ğŸ§ª Step 5: Launch the Replay

Choose your:
- Target schema: `RoomState v2`
- Source: `LabZone-A` or `labzone-temp-001`
- Time range: last hour, impulse range, full history

<aside class="border-l-4 border-yellow-400 bg-yellow-50 pl-4 text-yellow-900">
Rehydration plan:  
âœ… 32 RoomState entries recreated  
ğŸŸ¡ 4 impulses skipped (missing reference data)  
âŒ 0 signals triggered (suppressed on replay)
</aside>

<aside class="border-l-4 border-yellow-400 bg-yellow-50 pl-4 text-yellow-900">
This works even with 10k+ impulses â€” replay batches are memory-safe and CLI-scriptable.
</aside>

<aside class="border-l-4 border-neon-blue pl-4 italic text-neon-blue">
Some impulses couldnâ€™t be rehydrated â€” want to view whatâ€™s missing and add memory entries?
</aside>

RoomState updates. Drift visualizations shift.

<aside class="border-l-4 border-electric-purple pl-4 italic text-electric-purple">
Replay isnâ€™t just introspection â€” itâ€™s accountability at runtime.
</aside>

---

## ğŸ§ª Step 6: Integrate Runtime Memory

You just replayed history. Now you can pipe that reconstructed memory into the rest of your stack.

- **Prometheus Snapshot** â†’ feeds metrics into Grafana for live or historical dashboards
- **Webhook Previews** â†’ drive alerting rules, downstream system triggers, or custom routing
- **Structured Logs (`signals.json`, `RoomState-log.ndjson`)** â†’ ingest into Splunk, Redshift, S3, or your long-term analytics layer

```bash
openindustrial logs export --surface LabZone-A --format prometheus
```

<aside class="border-l-4 border-yellow-400 bg-yellow-50 pl-4 text-yellow-900">
Memory isnâ€™t just explainable â€” itâ€™s exportable.  
You can stream structure, signals, and reflex outcomes into any system you trust.
</aside>

<aside class="border-l-4 border-neon-blue pl-4 italic text-neon-blue">
â€œWant me to stream these replayed signals to your Grafana board, or just export the whole RoomState log to S3?â€
</aside>

<aside class="border-l-4 border-neutral-300 bg-neutral-50 text-neutral-700 text-sm">
ğŸ“ <strong>CLI Tip:</strong> You can preview a replay without committing it:

```bash
openindustrial replay plan \
  --surface LabZone-A \
  --schema RoomState \
  --from '2025-04-26T12:00:00Z' \
  --to '2025-04-26T16:00:00Z'
```
</aside>

<aside class="border-l-4 border-electric-purple pl-4 italic text-electric-purple">
You didnâ€™t just export logs. You exported alternate memory â€” what your system *could have known*.
</aside>

<figure class="my-16 flex flex-col items-center text-center max-w-xl w-full">
  <img
    src="/assets/docs/runtime-memory-integration.png"
    alt="Diagram showing RoomState replay outputs flowing to Prometheus, Webhooks, and S3."
    class="rounded-2xl shadow-2xl ring-1 ring-white/10 w-full"
  />
  <figcaption class="mt-4 text-sm text-neutral-400 tracking-wide uppercase">
    Memory export isnâ€™t a report â€” itâ€™s a runtime signal pipeline.
  </figcaption>
</figure>

---

## ğŸ§  Why Replay Matters

<aside class="border-l-4 border-yellow-400 bg-yellow-50 pl-4 text-yellow-900">
This isnâ€™t about recovering data.  
Itâ€™s about **re-evaluating understanding** in light of new structure.
</aside>

<aside class="border-l-4 border-electric-purple pl-4 italic text-electric-purple">
Your structure was late to the party.  
But it still remembers what should have happened.
</aside>

<aside class="border-l-4 border-yellow-400 bg-yellow-50 pl-4 text-yellow-900">
Replay doesnâ€™t just retell telemetry â€” it re-derives the full composite state based on schemas, joins, and reference memory you defined later.
</aside>

---

## âš™ï¸ CLI Parity

```bash
openindustrial replay \
  --surface LabZone-A \
  --schema RoomState \
  --from '2025-04-26T12:00:00Z' \
  --to '2025-04-26T16:00:00Z' \
  --dry-run
```

Use CLI to mirror Aziâ€™s replay options and verify what reflex memory would do.

---

## ğŸ’¬ Aziâ€™s Runtime Voice

| When | Azi Says |
|------|----------|
| Schema promoted late | â€œI saw 17 impulses before RoomState was ready. Want to backfill now?â€ |
| Replay preview | â€œThis wonâ€™t re-fire any signals. It just clarifies your structure.â€ |
| Export moment | â€œWant to forward this as a Prometheus push, webhook alert, or JSON artifact?â€ |
| Signal commit warning | â€œEven if you commit, reflexes will only fire if the state has changed since last time.â€ |
| Tieback to sim | â€œYou watched RoomMock fire. But did you ever ask what RoomState missed?â€ |

---

## âœ… What You Just Did

<aside class="border-l-4 border-neutral-300 bg-neutral-50 text-neutral-700 text-sm">
ğŸ“Š <strong>Want a visual recap?</strong> Scroll back to the <em>Impulse Diff</em>, <em>CI Hook</em>, and <em>Export Diagram</em> â€” each shows how replay exposes memory and powers real pipelines.
</aside>

- Saw what the runtime remembers and why
- Replayed telemetry into newly promoted structure
- Verified that reflex logic is explainable, idempotent, and exportable
- Streamed replayed memory to the systems you already use

---

## â†’ Up Next: Refine Your Reflexes

Fork `FanControlAgent`, deploy to a mocked SubSurface, and observe how logic improves when memory is reusable.

Reflex isnâ€™t just readable â€” itâ€™s evolvable.
