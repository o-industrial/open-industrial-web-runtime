# Deploy Your First Agent

Your schema is live. Now letâ€™s make the system respond to it.

<div class="mt-6 mb-8 px-6 py-4 border-l-4 border-indigo-500 dark:border-indigo-400 bg-indigo-50 dark:bg-indigo-950 text-indigo-900 dark:text-indigo-100 rounded">
  <strong>Systems are only as meaningful as their ability to act.</strong><br />
  This is your first moment of <strong>semantic execution</strong>.
</div>

---

## Define Your First Agent

We're going to create a logic unit that listens to `TemperatureSensor` impulses and controls a fan. Logic is now tied to meaning â€” not just data.

```ts
export default Agent()
  .Impulse(TemperatureSensorSchema)
  .Schemas(ctx => ({
    Fan: ctx.Connect(FanControllerSchema, "fan-controller-001", State.Current)
  }))
  .OnImpulse(async (impulse, ctx) => {
    const fan = ctx.Schemas.Fan;

    if (impulse.Temperature > 80 && fan.Power !== "on") {
      await fan.Commands.Power("on");
      return ctx.Status.Success("Fan turned on");
    }

    if (impulse.Temperature <= 80 && fan.Power !== "off") {
      await fan.Commands.Power("off");
      return ctx.Status.Success("Fan turned off");
    }

    return ctx.Status.Success("No action needed");
  });
```

This logic isnâ€™t a loop. Itâ€™s a reflex.
Each part binds intent to structure:
- `.Impulse` listens
- `.Schemas` connects context
- `.OnImpulse` defines behavior

Youâ€™ve built a single-schema reflex. Next, youâ€™ll compose behavior across context-bound memories.



---

## Deploy the Agent

1. Go to your **Agents** tab  
2. Click **Create New Agent** â†’ name it `FanControlAgent`  
3. Paste the logic above  
4. Bind it to `TemperatureSensor`  
5. Choose your execution surface (e.g., `dev-surface-01`)  
6. Hit **Deploy**  
Thatâ€™s it â€” no wiring, no polling, no pipelines. Logic is now live.

<aside class="border-l-4 border-gray-300 dark:border-gray-500 pl-4 italic text-gray-600 dark:text-gray-400">
âœ… <code>FanControlAgent</code> deployed to <code>dev-surface-01</code>. Iâ€™ll track each time it runs â€” and why.
</aside>

An execution surface is more than a runtime â€” itâ€™s a scope of intent. You define structure, bind behavior, and shape what happens inside.

---

## Trigger an Impulse

Letâ€™s simulate a sensor input:

```json
{
  "ID": "temperature-sensor-001",
  "Temperature": 84.2
}
```

This will trigger the agent and result in a fan toggle.

<figure class="my-16 flex flex-col items-center text-center max-w-xl w-full">
  <img
    src="/assets/docs/fan-agent-log.png"
    alt="Azi execution log showing FanControlAgent turning on the fan."
    class="rounded-2xl shadow-2xl ring-1 ring-white/10 w-full"
  />
  <figcaption class="mt-4 text-sm text-gray-400 dark:text-gray-500 tracking-wide uppercase">
    Deploy your agent to begin responding to live impulses.
  </figcaption>
</figure>

```txt
ğŸ”¹ Impulse received: Temperature = 84.2
ğŸ”¸ Agent matched: FanControlAgent
âš™ï¸ Command issued: turn_on â†’ fan-controller-001
âœ… Result: Fan turned on
```

<aside class="border-l-4 border-gray-300 dark:border-gray-500 pl-4 italic text-gray-600 dark:text-gray-400">
â€œAgent executed. Command sent to turn on the fan.â€
</aside>

Every agent response is visible in your run logs. You can explore inputs, decisions, and outcomes.

---

## What Just Happened

- The agent responded to a promoted schema
- It ran logic and issued a real command
- Azi tracked everything end-to-end

<aside class="border-l-4 border-gray-300 dark:border-gray-500 pl-4 italic text-gray-600 dark:text-gray-400">
If no schema match occurs, nothing runs. Azi logs the impulse â€” but your agent stays silent. Thatâ€™s how we protect intent.
</aside>

<div class="mt-6 mb-8 px-6 py-4 border-l-4 border-indigo-500 dark:border-indigo-400 bg-indigo-50 dark:bg-indigo-950 text-indigo-900 dark:text-indigo-100 rounded">
  <strong>Impulse â†’ Logic â†’ Action.</strong><br />
  Every execution is traceable. Every decision is explainable.
</div>

<aside class="border-l-4 border-gray-300 dark:border-gray-500 pl-4 italic text-gray-600 dark:text-gray-400">
Only <strong>promoted schemas</strong> can trigger logic. Thatâ€™s how we maintain meaning â€” and precision.
</aside>

Execution didnâ€™t happen because code was present â€” it happened because **structure matched**.
<aside class="border-l-4 border-gray-300 dark:border-gray-500 pl-4 italic text-gray-600 dark:text-gray-400">
FanControlAgent doesnâ€™t loop or watch a queue. It waits silently â€” until structure confirms itâ€™s valid. Thatâ€™s how the system ensures execution only happens when meaning is clear.
</aside>

---

## Whatâ€™s Next

This was your first working agent. From here, you can:

- Fork agents to test new logic
- Version and preview changes safely
- Chain behaviors across schemas
