# Deploy Your First Agent

Your schema is live. Now letâ€™s make the system respond to it.

<div class="mt-6 mb-8 px-6 py-4 border-l-4 border-indigo-500 dark:border-indigo-400 bg-indigo-50 dark:bg-indigo-950 text-indigo-900 dark:text-indigo-100 rounded">
  <strong>Systems are only as meaningful as their ability to act.</strong><br />
  This is your first moment of <strong>semantic execution</strong>.
</div>

---

## Understand the Agentâ€™s Job

You just promoted a schema. Now itâ€™s time to test whether the system truly listens.

An agent is a unit of logic that responds to structure â€” not just data:

- It listens for specific **impulses** (from promoted schemas)
- It connects to external **state** (through other schemas)
- It only acts when meaning is clear

Letâ€™s break that down.

Your promoted `TemperatureSensor` schema looks like this:

```json
{
  "ID": "temperature-sensor-001",
  "Temperature": 84.2
}
```

Now weâ€™ll promote a schema for your fan controller:

```json
{
  "ID": { "source": "connectionId", "type": "string", "primary": true },
  "Power": { "type": "string", "enum": ["on", "off"] }
}
```

This lets your agent understand not just what the temperature *is* â€” but what the fan is *already doing*.

Thatâ€™s how logic becomes **context-aware**.

> Youâ€™re not writing an if-statement.
> Youâ€™re defining a reflex â€” scoped by structure, governed by schema.

---

## Define Your First Agent

Letâ€™s build your first agent â€” one that listens to your schema and responds in real time.
Youâ€™ve already defined the structure. Now, letâ€™s define the behavior.

```ts
export default Agent()
  .Impulse(TemperatureSensorSchema)
  .Schemas(ctx => ({
    Fan: ctx.Connect(FanControllerSchema, "fan-controller-001", State.Current)
  }))
  .OnImpulse(async (impulse, ctx) => {
    const fan = ctx.Schemas.Fan;

    if (impulse.Temperature > 80 && fan.Power !== "on") {
      await fan.Commands.Power("on");
      return ctx.Status.Success("Fan turned on");
    }

    if (impulse.Temperature <= 80 && fan.Power !== "off") {
      await fan.Commands.Power("off");
      return ctx.Status.Success("Fan turned off");
    }

    return ctx.Status.Success("No action needed");
  });
```

This logic isnâ€™t a loop. Itâ€™s a reflex.
Each part binds intent to structure:
- `.Impulse` listens
- `.Schemas` connects context
- `.OnImpulse` defines behavior

Youâ€™ve built a single-schema reflex. Next, youâ€™ll compose behavior across context-bound memories.



---

## This Is When the System Listens

Youâ€™ve defined structure. Youâ€™ve written logic. Now itâ€™s time to find out if the system truly respects both.

This is your first deployment â€” the moment when authored meaning becomes **active behavior**.

But itâ€™s not a function. Not a poller. Not a service waiting in a loop.

An agent only activates when:
- The **structure is promoted**
- The **impulse matches**
- The **execution surface is listening**

This is what makes the system **governed, intentional, and safe**.

> If nothing matches, nothing runs.  
> If meaning is confirmed â€” the system acts.

---

## Activate the Agent

Open your **Agents** tab and click **Create New Agent**.

- Name it `FanControlAgent`
- Paste in your logic
- Bind it to `TemperatureSensor`
- Choose your surface (e.g., `dev-surface-01`)
- Click **Deploy**

Thatâ€™s it â€” no wiring, no polling, no pipelines. Youâ€™ve just activated structure-bound behavior.  
Thatâ€™s it â€” no wiring, no polling, no pipelines. Logic is now live.

<aside class="border-l-4 border-neon-blue pl-4 italic text-neon-blue">
âœ… <code>FanControlAgent</code> deployed to <code>dev-surface-01</code>. Iâ€™ll track each time it runs â€” and why.
</aside>

An execution surface is more than a runtime â€” itâ€™s a scope of intent. You define structure, bind behavior, and shape what happens inside.

---

## Observe the System Respond

Now letâ€™s test the reflex. When a real `TemperatureSensor` input flows in:

```json
{
  "ID": "temperature-sensor-001",
  "Temperature": 84.2
}
```

This matches your agentâ€™s declared logic. Azi reacts â€” visibly and precisely.

<figure class="my-16 flex flex-col items-center text-center max-w-xl w-full">
  <img
    src="/assets/docs/fan-agent-log.png"
    alt="Azi execution log showing FanControlAgent turning on the fan."
    class="rounded-2xl shadow-2xl ring-1 ring-white/10 w-full"
  />
  <figcaption class="mt-4 text-sm text-gray-400 dark:text-gray-500 tracking-wide uppercase">
    Deploy your agent to begin responding to live impulses.
  </figcaption>
</figure>

```txt
ğŸ”¹ Impulse received: Temperature = 84.2
ğŸ”¸ Agent matched: FanControlAgent
âš™ï¸ Command issued: turn_on â†’ fan-controller-001
âœ… Result: Fan turned on
```

<aside class="border-l-4 border-neon-blue pl-4 italic text-neon-blue">
â€œAgent executed. Command sent to turn on the fan.â€
</aside>

Every agent response is visible in your run logs. You can explore inputs, decisions, and outcomes.

---

### âœ… System Check

- âœ… Agent matched: `TemperatureSensor`
- âœ… Context fetched: `fan-controller-001`
- âœ… Action taken: `Power = on`
- âœ… Outcome logged and visible

---

## What Just Happened

- The agent responded to a promoted schema
- It ran logic and issued a real command
- Azi tracked everything end-to-end

<aside class="border-l-4 border-neon-blue pl-4 italic text-neon-blue">
If no schema match occurs, nothing runs. Azi logs the impulse â€” but your agent stays silent. Thatâ€™s how we protect intent.
</aside>

<div class="mt-6 mb-8 px-6 py-4 border-l-4 border-indigo-500 dark:border-indigo-400 bg-indigo-50 dark:bg-indigo-950 text-indigo-900 dark:text-indigo-100 rounded">
  <strong>Impulse â†’ Logic â†’ Action.</strong><br />
  Every execution is traceable. Every decision is explainable.
</div>

<aside class="border-l-4 border-neon-blue pl-4 italic text-neon-blue">
Only <strong>promoted schemas</strong> can trigger logic. Thatâ€™s how we maintain meaning â€” and precision.
</aside>

Execution didnâ€™t happen because code was present â€” it happened because **structure matched**.

<aside class="border-l-4 border-neon-blue pl-4 italic text-neon-blue">
FanControlAgent doesnâ€™t loop or watch a queue. It waits silently â€” until structure confirms itâ€™s valid. Thatâ€™s how the system ensures execution only happens when meaning is clear.
</aside>

---

## Whatâ€™s Next

This was your first working agent. But agents are just the beginning.

Soon, you'll:
- Link multiple schemas with `RoomState` or `Schedule`
- Add reasoning or OpenAI explanations to logic
- Deploy to SubSurfaces for scoped test/observe flows

From here, you can:

- Fork agents to test new logic
- Version and preview changes safely
- Chain behaviors across schemas
