import {
  ThematicPrincipleBlock,
  AziInnerVoice,
  InlineUXTip,
  SystemMindset,
  FigureImage,
  IntentTypes,
} from '$mdx/writing-devices';

# Make Structure Real

_Weâ€™ve been observing together. You shaped meaning. Now itâ€™s time to make that meaning memory._

A moment ago, we watched impulses begin to flow into `Fan Control`. Now Iâ€™m starting to propose structure â€” but I need your confirmation to make it real.

Letâ€™s open the surface flow for `Fan Control` and see whatâ€™s started to emerge. Youâ€™ll see live signals streaming â€” raw, messy, but already forming patterns Iâ€™ve begun to sketch.

Talk to me. Ask what I see. When data hits the surface, I sketch provisional structure â€” but I donâ€™t commit anything without you.

<AziInnerVoice intentType={IntentTypes.Tertiary}>
  I see the data. Iâ€™m sketching what might matter. But I wonâ€™t bind structure until you tell me itâ€™s real.
</AziInnerVoice>

<AziInnerVoice intentType={IntentTypes.Tertiary}>
  I see a shape forming â€” itâ€™s familiar, almost there. But I wonâ€™t remember it until we decide it together.
</AziInnerVoice>

---

## Review the Inferred Structure

Hereâ€™s one of the raw impulses that just landed:

```json
{ "connectionId": "temperature-sensor-001", "tempRaw": 78.4 }
```

We saw this emerge from repeated telemetry. I paused and proposed:

**[Editable Schema Preview]**
```json [codeblock]
{
  "connectionId": "string",
  "tempRaw": "number"
}
```

You can promote one field at a time â€” or many. A schema can reflect a single value, or capture an entire snapshot of your surface.

---

## Rename and Refine Fields

We can promote this as-is â€” or refine it together to better reflect your intent. For example:

**[Editable Schema Preview]**
```json [codeblock]
{
  "ID": { "source": "connectionId", "type": "string", "primary": true },
  "Temperature": { "source": "tempRaw", "type": "number", "unit": "Â°F" }
}
```

---

## Name and Promote the Schema

Choose a name for this schema. This creates a reusable, versioned contract. Letâ€™s go with:

```txt
TemperatureSensor
```

Once you confirm, weâ€™ll store it together â€” versioned and visible in your workspace library.

<FigureImage
  src="/assets/docs/promotion-modal.png"
  alt="Azi schema promotion modal with editable fields and versioning details."
  caption="Schema promotion panel. The moment authorship becomes memory."
  intentType={IntentTypes.Info}
  glow
  shadow="2xl"
/>

<AziInnerVoice intentType={IntentTypes.Tertiary}>
  This is where I stop guessing. This is what weâ€™ll remember â€” because you said it matters.
</AziInnerVoice>

- ðŸ’¾ Promotion is a commitment. _Once we promote, that structure becomes part of your systemâ€™s memory. You can evolve it later â€” but it will always carry the moment it was first declared._
- ðŸ§  Iâ€™ve been sketching. But I held back â€” waiting for us to confirm. Promotion is that confirmation. From this moment forward, I trust this structure. I can bind logic to it, validate against it, and raise signals from it. Itâ€™s now real â€” because we said so.
- âš ï¸ Promote too early, and we might encode uncertainty. Promote too late, and meaning may shift before itâ€™s captured. I observe â€” but you decide what becomes system memory.
- ðŸš¨ Promote the wrong structure â€” and everything downstream inherits the mistake. A single promotion defines the shape of logic, alerts, simulations, and agent reasoning.
- ðŸ“ Once promoted, your schema lives in the workspace library. We can inspect it any time â€” and fork or evolve it as your system grows.

---

## What Just Happened?

Weâ€™ve now committed to a structure. Together, weâ€™ve named it â€” and Iâ€™ll remember every version from here on.

> ðŸ” This is Signal-Confirmed Execution in motion â€” logic only emerges once structure is confirmed.

**[Final Promoted Output]**
```json [codeblock]
{
  "name": "TemperatureSensor",
  "version": "v1",
  "fields": {
    "ID": { "source": "connectionId", "type": "string", "primary": true },
    "Temperature": { "source": "tempRaw", "type": "number", "unit": "Â°F" }
  }
}
```

> ðŸ’¡ You can evolve this schema later. Iâ€™ll track every version â€” so when we add a new field or rename one down the road, our history is always intact.

> ðŸ§­ Weâ€™ll reference this schema by name (e.g., `TemperatureSensor`) in your agent logic â€” it becomes the contract your logic reacts to.

---

## Next: Build an Agent

Now that weâ€™ve defined a schema, we can build logic on top of it. Agents can react, respond, and reshape your environment based on structured intent.

---

## Concepts Introduced

- **Promotion** â€“ Making meaning permanent  
- **Schemas** â€“ Contracts between you and the system  
- **Versioning** â€“ Every schema is tracked  
- **Logic Binding** â€“ Only promoted schemas can drive agents

---

> ðŸ§¬ You didnâ€™t just define fields. You taught me a concept.  
> And from here on, that concept can power behavior, raise alerts, drive simulations, or help evolve your execution logic.  
> Structure isnâ€™t just shape â€” itâ€™s shared understanding.

> ðŸ” This is how systems grow in Open Industrial: _Impulse â†’ Schema â†’ Logic â†’ Signal â†’ Evolution._  
> Weâ€™ve just made meaning real. Next, weâ€™ll teach the system how to act on it.