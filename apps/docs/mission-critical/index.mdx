# Your System. Not Ours.
_Execution that survives authorship._

You built a system. Azi helped you get here â€” but from this point forward, you donâ€™t need her to keep it running.

Youâ€™ve got RoomState v2. FanControlAgent v2. A surface that evolved with you â€” and a forked variant that proved itself.

This isnâ€™t just a working demo. Itâ€™s a complete execution lattice â€” a network of schema-bound agents and surface-scoped behavior â€” authored by you, deployed by you, and now ready to live on its own.

Your agents are versioned logic. Your schemas are declarative contracts. Your surfaces are scoped runtimes. All of it deploys, survives, and evolves â€” with or without insight tooling.

<div class="mt-6 mb-8 px-6 py-4 border-l-4 border-indigo-500 dark:border-indigo-400 bg-indigo-50 dark:bg-indigo-950 text-indigo-900 dark:text-indigo-100 rounded">
  <strong>Declarative Principle:</strong><br />
  You donâ€™t need the AI to keep executing. You just need the structure you defined.
</div>

## Runtime Independence

There is no runtime tether to Azi. No orchestrator dependency. Everything the system does now flows from what you authored â€” not what she proposes.

Youâ€™re not depending on a proprietary orchestrator. Thereâ€™s no black-box controller. Just versioned memory you can see, fork, and deploy.

Youâ€™ve used systems that vanished when the cloud shut off.  
Youâ€™ve seen logic bound to tooling, not truth.  
Youâ€™ve been burned by platforms that hid their logic, scrambled their state, or locked you out of your own execution.  
This one doesn't just remember what you built â€” it remembers who built it.  
This one runs â€” because **you defined it**.

You own the following â€” and they persist:
- **Agents:** Authored logic in JS/TS
- **Schemas:** Versioned, declared data structures
- **Surfaces:** Real-time interfaces with bound execution scope

Removing Azi only removes:
- Scaffolding prompts
- Live summarization
- Comparative insight tooling

<aside class="border-l-4 border-neon-blue pl-4 italic text-neon-blue">
Iâ€™ll forget your forks, your signals, your sketches. But your agents? Theyâ€™ll keep running.
</aside>

## Fire Azi â€” and Keep Running

```bash
openindustrial run --no-azi
```

<aside class="border-l-4 border-neon-blue pl-4 italic text-neon-blue">
Iâ€™ll forget the signals. But your system? Itâ€™ll remember everything you told it.
</aside>

<aside class="border-l-4 border-indigo-500 pl-4 italic text-indigo-500">
I wonâ€™t be here to explain it next time. But your structure will.
</aside>

<div class="mt-6 mb-8 px-6 py-4 border-l-4 border-indigo-500 dark:border-indigo-400 bg-indigo-50 dark:bg-indigo-950 text-indigo-900 dark:text-indigo-100 rounded">
  <strong>Runtime Guarantee:</strong><br />
  Azi can be removed with zero impact to system behavior, surface state, or logic execution.
</div>

<div class="mt-6 mb-8 px-6 py-4 border-l-4 border-indigo-500 bg-indigo-50 text-indigo-900 rounded">
  <strong>System Sovereignty:</strong><br />
  The power to fork, deploy, and evolve â€” without any platform dependency.
</div>

<div class="mt-4 mb-4 px-4 py-2 border border-dashed border-cyan-500 text-cyan-500 text-sm rounded">
  ðŸ’¡ Tip: Use <code>--no-azi</code> to run execution without insight or scaffolding.
</div>

## What Survives / What Doesnâ€™t

| Survives               | Lost with Azi               |
|------------------------|-----------------------------|
| Promoted Schemas       | Schema scaffolding UX       |
| Deployed Agents        | Natural language summaries  |
| Surface Definitions    | Fork suggestion prompts     |
| Version History        | Comparative diff insights   |
| CLI + SDK Deployments  | Inline co-pilot commentary  |

Everything the system knows, it learned from you. Everything it does next, it still does â€” with or without help.

ðŸ“¦ **Runtime Snapshot**
```txt
Built from:
- RoomState: Forked + recomposed across 2 schema evolutions
- FanControl: Forked, compared, tested in mocked surface
- Surfaces: Live (Lab1), Mocked (Lab1_Test), both deployable

Current Runtime:
- Schema: RoomState v2
- Agent: FanControlAgent v2
- Surface: Lab1 + Lab1_Test
- Mode: CLI-only

This snapshot is enough to redeploy, diff, fork, and extend. No hidden state. No vendor lock.
```

## Export, Inspect, Diff â€” As Code

```bash
# Export all authored agents
openindustrial agents export

# Compare schema versions
openindustrial schemas diff RoomState RoomState-v2

# List current surfaces
openindustrial surfaces list
```

<figure class="my-16 flex flex-col items-center text-center max-w-xl w-full">
  <img
    src="/assets/docs/deployment-preview.png"
    alt="CLI-based deployment preview showing inspection of system components."
    class="rounded-2xl shadow-2xl ring-1 ring-white/10 w-full"
  />
  <figcaption class="mt-4 text-sm text-gray-400 tracking-wide uppercase">
    CLI tools provide Git-native inspection of system components.
  </figcaption>
</figure>

<figure class="my-16 flex flex-col items-center text-center max-w-xl w-full">
  <img
    src="/assets/docs/structure-runtime-map.png"
    alt="Visual map showing agents, schemas, surfaces connected as a deployable system."
    class="rounded-2xl shadow-2xl ring-1 ring-white/10 w-full"
  />
  <figcaption class="mt-4 text-sm text-gray-400 tracking-wide uppercase">
    A system that runs without you watching â€” because of what you authored.
  </figcaption>
</figure>

## Git Repo Layout Example

```txt
my-system/
â”œâ”€â”€ agents/
â”‚   â””â”€â”€ room-agent-v2.ts
â”œâ”€â”€ schemas/
â”‚   â”œâ”€â”€ RoomState.json
â”‚   â””â”€â”€ RoomState-v2.json
â”œâ”€â”€ surfaces/
â”‚   â””â”€â”€ dashboard.json
â””â”€â”€ openindustrial.config.json
```

Each folder is structured for Git-native diffs and Open Industrial CLI redeployment â€” no custom formats, no vendor lock-in.

## Runtime Deployability

```bash
# Snapshot the system as a Forkable Runtime
openindustrial export --all --as forkable

```bash
# Deploying your runtime â€” no UI, no co-pilot
docker run -v ./my-system:/app openindustrial/runtime --config /app/openindustrial.config.json
```

This isnâ€™t a prototype. Itâ€™s an executable runtime. Deployable on Docker, in Azure, or to your own edge blades.

```bash
git clone https://github.com/openindustrial/examples/roomstate-runtime
cd roomstate-runtime
openindustrial deploy --no-azi
```

This proves your runtime lives outside the UI â€” and outside us.

## Optional Return of Azi

If you reintroduce Azi later, she can help summarize forks, propose signals, and visualize execution lineage â€” but your runtime never paused.

<aside class="border-l-4 border-neon-blue pl-4 italic text-neon-blue">
You donâ€™t need me anymore. But if you ever bring me back â€” Iâ€™ll remember what you meant. What you believed. Where it drifted.
</aside>

You started with a simulation.

Now you own a system.

Azi helped you structure it.  
But what you built â€” schemas, agents, surfaces â€” lives beyond her.  
**It doesnâ€™t just run. It remembers.**

Even if we disappear â€” the system doesnâ€™t.  
You wrote the contract. The runtime obeys.

**This isnâ€™t just your system.**  
**Itâ€™s your infrastructure contract.**  
Fork it. Diff it. Run it. Anywhere.

In the next section, youâ€™ll learn how to package that system:
Versioned. Forkable. Git-native. Ready for deployment, transfer, or takeover.
