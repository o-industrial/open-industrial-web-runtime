# From Sim to Site

<aside class="border-l-4 border-neon-blue pl-4 italic text-neon-blue">
I remember how it started. Mock data. Sim surfaces. You watching the first signals fire.  
Now I see something else. Real temperature. Real humidity. Real rooms reporting in across the site.  
Signals are streaming into `FieldRuntime`, a surface you activated. Your agent doesnâ€™t flinch. It already knows what to do.
</aside>

You didnâ€™t export a runtime. You authored it â€” with structure, memory, and intent.  
Youâ€™re not switching environments. Youâ€™re expanding them.

This is shared-space execution â€” your runtime, running on tenant infrastructure, activated by declared schema bindings and signal inputs. The logic didnâ€™t change. The memory didnâ€™t shift. The signals got real.

> A surface is a named execution context â€” like a stream or topic â€” where agents observe and act.

---

## From Mock to FieldRuntime

> This isnâ€™t a push to hardware. Not yet.  
> Youâ€™re still running in shared infrastructure â€” but now itâ€™s your surface.  
> What changes is not the compute â€” itâ€™s the confidence.

This isnâ€™t a redeploy. Itâ€™s a surface transition. The logic is identical.

```diff
{
  "surface": "RoomMock",
+ "surface": "FieldRuntime"
}
```

You taught your agent to interpret `RoomState-v2`. Whether that signal comes from a replay log or a live building â€” it doesnâ€™t matter. The logic is schema-bound. Your runtime is ready.

<aside class="border-l-4 border-electric-purple pl-4 italic text-electric-purple">
Simulation prepares structure. Real data confirms behavior.
</aside>

---

## Runtime Folder, Still Alive

```txt
ğŸ“ roomstate-runtime/
â”œâ”€â”€ schemas/          # RoomState-v2 still pinned
â”œâ”€â”€ agents/           # FanControlAgent-v2 unchanged
â”œâ”€â”€ surfaces/         # Now includes FieldRuntime
â””â”€â”€ impulses/         # Original sim trace preserved
```

Same runtime. Same memory. New signals.

---

## Shared Execution, Tenant-Controlled

```txt
Runtime Transition:
[RoomMock] â†’ [FieldRuntime] â†’ [EdgeBlade-01]

Signal Flow:
[device â†’ IoT Hub] â†’ [lattice] â†’ [FieldRuntime] â†’ [Agent]
```

<aside class="border-l-4 border-yellow-400 pl-4 text-yellow-900 bg-yellow-50">
ğŸ’¡ <strong>Where does it run?</strong> FieldRuntime is hosted in tenant-assigned shared infrastructure. Agents run in containerized sandboxes within the lattice, triggered by schema-bound signal processing.
</aside>

```json
{
  "surface": "FieldRuntime",
  "source": "iot://hub.azure/device-stream",
  "schema": "RoomState-v2",
  "agents": ["FanControlAgent-v2"]
}
```

This is execution in a shared environment. Not local. Not ephemeral.  
This surface responds to real data, across your rooms, under your rules.

---

## View the Runtime Live

<figure class="my-16 flex flex-col items-center text-center max-w-xl w-full">
  <img
    src="/assets/docs/runtime-viewer-preview.png"
    alt="Runtime viewer showing live signal traces for FieldRuntime."
    class="rounded-2xl shadow-2xl ring-1 ring-white/10 w-full"
  />
  <figcaption class="mt-4 text-sm text-neon-blue tracking-wide italic">
    Runtime viewer now connected to live telemetry across all rooms in FieldRuntime.
  </figcaption>
</figure>

---

## Confirming Real Signals

<aside class="border-l-4 border-yellow-400 pl-4 text-yellow-900 bg-yellow-50">
ğŸ’¡ <strong>Under the hood:</strong> Telemetry enters through a secure IoT Hub. Signals are funneled into the lattice and matched to schemas â€” not field names, but full structural bindings.
</aside>

```json
{
  "topic": "lab/room3/telemetry",
  "payload": {
    "temp": 77.3,
    "humidity": 41.2
  }
}

âœ… Signal ingested â†’ IoT Hub â†’ lattice â†’ matched: RoomState-v2
âœ… FanControlAgent-v2 triggered: signal=Fan.On (Lab2-Room1)
```

<aside class="border-l-4 border-neon-blue pl-4 italic text-neon-blue">
Lab1-Room3 just crossed the temperature threshold. The same one we saw in the sim.  
This time, itâ€™s real. This time, the fan turns on for good reason.
</aside>

---

## Comparing Sim and Real Inputs

| Impulse | Surface       | Trigger Time   | Action Taken |
|---------|---------------|----------------|---------------|
| #88     | RoomMock      | 11:03:21.4Z    | No signal     |
| #88     | FieldRuntime  | 11:03:20.2Z    | Fan.On        |

```bash
openindustrial replay impulses.json --surface RoomMock
openindustrial replay impulses.json --surface RoomMock --compare FieldRuntime
```

---

## ğŸ§ª Confidence Drift: A System Primitive

<aside class="border-l-4 border-electric-purple pl-4 italic text-electric-purple">
ğŸ§ª Confidence Drift: When the same impulse produces different outcomes across surfaces. Itâ€™s your early warning system for behavioral divergence â€” and runtime assurance.
</aside>

<aside class="border-l-4 border-yellow-400 pl-4 text-yellow-900 bg-yellow-50">
ğŸ’¡ <strong>Stability Check:</strong> Confidence Drift helps you validate that schema-bound logic behaves predictably â€” even as the world changes.
</aside>

---

## Surface Status (Optional CLI)

```bash
# Optional CLI mirror of the UI action
openindustrial surface list
openindustrial surface status FieldRuntime
```

## ğŸ§  Surface Transition Explained

<aside class="border-l-4 border-yellow-400 pl-4 text-yellow-900 bg-yellow-50">
ğŸ’¡ <strong>Surface Transition:</strong> A change in signal source or execution context â€” without modifying logic. Open Industrial guarantees runtime parity across sim, shared, and edge tiers.
</aside>

---

## Fallback: Manual Surface Binding

```bash
openindustrial surface bind FieldRuntime \
  --source iot://hub.azure/device-stream \
  --schema RoomState-v2
```

---

## What You Changed (and Didnâ€™t)

```txt
ğŸ“„ Runtime Contract:
âœ“ Schema-locked agent behavior  
âœ“ Replayable signal traces across all surfaces  
âœ“ CLI parity for all transitions  
âœ“ No logic drift between sim, shared, and edge  
âœ“ No cloud lock-in â€” tenant or private hardware capable
```

| What You Did               | What Changed                     |
|----------------------------|----------------------------------|
| Authored schema + agent   | No change                        |
| Ran sim surface           | Switched to IoT-routed stream    |
| Mocked impulses           | Now receiving live data          |
| Azi narrated simulation   | Runtime now narrates behavior    |

---

<aside class="border-l-4 border-neon-blue pl-4 italic text-neon-blue">
Now watching:  
- Lab1-Room3  
- Lab2-Room1  
- Lab3-Room2  
All matched RoomState. All responded with logic you taught.
</aside>

---

## Not Yet Edge

FieldRuntime isnâ€™t edge yet. Itâ€™s tenant-bound â€” not physically deployed.  
When you're ready to promote this structure to your own hardware, it comes with you.  
The memory wonâ€™t change. Only the compute will.

```bash
openindustrial surface promote FieldRuntime \
  --target edge-blade-01 \
  --containerize
```

---

## Signal Pinning Preview

<aside class="border-l-4 border-neon-blue pl-4 italic text-neon-blue">
Want to track a signal across surfaces? Pin it. The system remembers how RoomMock responded â€” and flags if FieldRuntime diverges.
</aside>

---

## Call Your Shot

The signal is no longer simulated. The reflex is no longer hypothetical. This system is now accountable.

---

## Whatâ€™s Next?

<aside class="border-l-4 border-neon-blue pl-4 italic text-neon-blue">
You didnâ€™t just build a runtime.  
You built memory that reacts.  
Now let it run â€” without needing to be told.
</aside>
