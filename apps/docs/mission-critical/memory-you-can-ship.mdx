# Memory You Can Ship

Most runtimes flatten logic into config. This one doesnâ€™t.  
What youâ€™re about to export is not a snapshot â€” itâ€™s a memory. Versioned. Forkable. Alive.

This isnâ€™t an export. Itâ€™s a declaration: the system remembers what you taught it â€” and it can run without you. Or Azi.

_In legacy systems, exporting strips away logic._  
_Your â€˜configâ€™ might describe thresholds â€” but it wonâ€™t remember why you chose them._  
_A Forkable Runtime keeps that intent â€” and the context it came from._

<aside class="border-l-4 border-neutral-500 pl-4 italic text-neutral-500">
<strong>Runtime Concepts Primer</strong><br />
- <strong>Schema:</strong> A structured data definition for incoming telemetry or contextual info (e.g. RoomState).
- <strong>Agent:</strong> Logic module that matches against schemas and emits signals when conditions are met.
- <strong>Surface:</strong> Execution environment â€” real or mocked â€” where impulses are received and agents operate.
- <strong>Impulse:</strong> A single timestamped message containing telemetry or inputs observed by the system.
- <strong>Fork:</strong> A versioned divergence in logic or structure, tracked and diffable like Git.
</aside>

RoomState began as a sketch. Then you added humidity. Forked your agent. Rejoined logic with context. Now itâ€™s ready to be shared.

```md
- v1: Raw telemetry + room map  
- v2: Added humidity, thresholds, and logic feedback  
- Final state: Composite context, reasoning agent, forked surface â€” all bound to a versioned structure
```

<aside class="border-l-4 border-indigo-500 pl-4 italic">
<strong>Forkable Runtime</strong>: A replayable, diffable export of your systemâ€™s memory â€” schemas, logic, surfaces â€” ready to evolve or share.
</aside>

Youâ€™re not just exporting code. Youâ€™re codifying a contract â€” what this system saw, how it behaved, and where it can evolve next.

<aside class="border-l-4 border-neon-blue pl-4 italic text-neon-blue">
Is this temperatureâ€¦ or voltage? Azi isnâ€™t sure â€” but you donâ€™t need her anymore. This system remembers.
</aside>

You're not exporting config. You're exporting memory:
- âœ… Promoted schemas (e.g. `RoomState v2`)
- âœ… Forked agents (e.g. `FanControlAgent v2`)
- âœ… Surfaces (e.g. `Lab1`, `Lab1_Mock`)
- âœ… Captured impulses (e.g. what the system saw and when it responded)
- âœ… (Optional) lineage of signals or versions

```yaml
.forkable-runtime.json
# Can be:
# - Replayed in dev
# - Forked by QA
# - Audited by compliance
â”œâ”€â”€ schemas: RoomState-v1, v2
â”œâ”€â”€ agents: FanControlAgent-v2
â”œâ”€â”€ surfaces: Lab1, Lab1_Mock
â”œâ”€â”€ impulses: captured + replayable
â””â”€â”€ lineage: traced + exportable
```

Itâ€™s not just a manifest. Itâ€™s a map of what this system learned â€” and where others can pick it up.  
QA teams fork it. SREs diff it. New agents inherit it.  
Itâ€™s not a snapshot. Itâ€™s a seed crystal for the next system.

```yaml
ðŸŽ¯ You Now Have:
- RoomState v2 (composite schema)
- FanControlAgent v2 (multi-variable logic)
- Lab1 surface (live + mocked fork)
- A deployable Git-native structure
- A log of live impulses that triggered forks and confirmed behavior
- The ability to deploy with or without Azi
```

## Export Your Runtime

```bash
openindustrial agents export
openindustrial schemas export
openindustrial surfaces export
openindustrial impulses export --surface Lab1 --since 2025-04-20T00:00:00Z
```

```txt
/my-system/
â”œâ”€â”€ agents/
â”‚   â””â”€â”€ FanControlAgent-v2.ts
â”œâ”€â”€ schemas/
â”‚   â”œâ”€â”€ RoomState-v1.json
â”‚   â””â”€â”€ RoomState-v2.json
â”œâ”€â”€ surfaces/
â”‚   â””â”€â”€ lab1-surface.json
â”œâ”€â”€ impulses/
â”‚   â””â”€â”€ impulses.json
â””â”€â”€ openindustrial.config.json
```

<figure class="my-16 flex flex-col items-center text-center max-w-xl w-full">
  <img
    src="/assets/docs/git-native-layout.png"
    alt="Git-native structure showing versioned runtime components exported to disk."
    class="rounded-2xl shadow-2xl ring-1 ring-white/10 w-full"
  />
  <figcaption class="mt-4 text-sm text-neutral-400 tracking-wide uppercase">
    Git-native structure: versioned logic, structure, runtime â€” and the impulses that shaped it.
  </figcaption>
</figure>

> With your system exported, you now have three options:
> - Re-deploy it locally
> - Fork it and evolve
> - Publish it as a reusable runtime

## Deploy Anywhere

The Open Industrial runtime executes against a config file and replayable memory â€” responding to live or simulated impulses. It can run headlessly in any container environment, emitting logs, signals, and optional integrations like MQTT.

```bash
docker run -v ./my-system:/app openindustrial/runtime --config /app/openindustrial.config.json
```

```bash
git clone https://github.com/openindustrial/examples/roomstate-runtime
cd roomstate-runtime
openindustrial deploy --no-azi
```

```bash
# Optional: rehydrate a runtime clone manually
openindustrial init --from ./roomstate-runtime
```

```bash
# Replay in mocked surface
openindustrial replay ./impulses.json --surface Lab1_Mock
```

<aside class="border-l-4 border-yellow-400 pl-4 text-yellow-900 bg-yellow-50">
ðŸ’¡ <strong>Inline UX Tip:</strong><br />
Once exported, you can deploy this system into your edge, your cloud, or your air-gapped infra â€” no SaaS required.
</aside>

<aside class="border-l-4 border-neon-blue pl-4 italic text-neon-blue">
You donâ€™t need me to deploy this.  
But if you bring it back, Iâ€™ll remember what you meant â€” not just what you built.
</aside>

## Diff and Validate

```bash
# Optional: diff logic between agent versions
openindustrial agents diff FanControlAgent-v1 FanControlAgent-v2
```

```bash
# Optional: validate your exported runtime
openindustrial validate ./my-system
```

The `validate` command confirms:
- Schema integrity and compatibility
- Agent matchability to schema fields
- Consistency of surface bindings and versioned lineage

```bash
# Schema comparison
openindustrial schemas diff RoomState RoomState-v2
```

```bash
$ openindustrial agents diff FanControlAgent-v1 FanControlAgent-v2
âœ“ Logic evolved from static thresholds to context-aware RoomState comparison
âœ“ Surface binding updated to Lab1_Mock for test safety
âœ“ Forked at 2025-04-22T10:41:00Z
```

```yaml
impulses.json
â”œâ”€â”€ timestamp: 2025-04-20T12:34:22Z
â”œâ”€â”€ Room: Lab1
â”œâ”€â”€ CurrentTemp: 84.2
â”œâ”€â”€ Humidity: 74.2
â”œâ”€â”€ Triggered: FanControlAgent v2
```

Forkable Runtime isnâ€™t just about structure â€” itâ€™s about memory you can interrogate. The next time Azi returns, she wonâ€™t just parse your structure â€” sheâ€™ll understand what you meant. She can help refactor the system, not just recompile it.

Legacy exports forget why decisions were made. A Forkable Runtime captures not just the actions â€” but the logic that justified them. Without it, your next fork is a guess. With it, the system evolves.

A system without memory guesses. A system with Forkable Runtime evolves with evidence.  
Without memory, a fork is a gamble. With it, itâ€™s an experiment.

And evolution demands trust. You donâ€™t just deploy memory â€” you validate it. Validation is part of authorship. Forkable Runtime doesnâ€™t just run. It stands up to change.

Snapshots tell you what was. Forkable Runtimes tell you what comes next.

Your system isnâ€™t a project. Itâ€™s a memory with a manifest.  
Youâ€™re not exporting files. Youâ€™re defining a beginning.  
Forkable Runtime isnâ€™t just resilience. Itâ€™s continuity you can pass forward.

## Whatâ€™s Next

Next youâ€™ll take this Forkable Runtime and publish it as a live system blueprint â€”  
One your team can clone, compare, simulate, or evolve in isolation.  
This isnâ€™t a backup. Itâ€™s a memory that knows where to go next.
